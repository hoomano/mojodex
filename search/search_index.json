{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Mojodex is a digital assistant that supports professionals by automating text-related tasks.</p> <p>\ud83c\udf1f Our motivation is to create the open standard on how to create enterprise level agents</p>"},{"location":"#what-does-it-do","title":"What does it do?","text":""},{"location":"#what-can-companies-do-with-mojodex","title":"What can companies do with Mojodex?","text":"<ul> <li> <p> Recruitment Assistance</p> <p>Custom Interview Recaps: Teams of 8-10 members use Mojodex to standardize their interview processes, ensuring consistent and well-structured interview summaries.</p> </li> <li> <p> Sales Process Enhancement</p> <p>On-the-Go Sales Support: Sales teams utilize Mojodex to streamline their workflow, capturing conversation details directly into their CRM while traveling between meetings.</p> </li> <li> <p> Proprietary Consulting Assistants</p> <p>Secure Customer Data Handling: Consulting teams create tailored assistants with Mojodex to manage sensitive customer information on their own secure infrastructure.</p> </li> <li> <p> Customer Relationship Management</p> <p>Guided Communication for Newcomers: Customer success teams employ digital assistants to mentor new members, leveraging internal data and established procedures from over 20 years of customer engagement in the sound factory industry.</p> </li> </ul> <p>Beyond those examples: Make it your own</p> <p>Mojodex is designed to be flexible and adaptable to a wide range of use cases. It can be tailored to fit the specific needs of any business, from small startups to large enterprises.</p>"},{"location":"#whats-unique-with-mojodex","title":"What's unique with Mojodex?","text":""},{"location":"#not-just-a-chatbot-like-chatgpt","title":"Not Just a Chatbot like ChatGPT","text":"<p>Mojodex goes beyond reactive chatbot functionality. It proactively guides users, responds proactively, and assists in various tasks, not just instant Q&amp;A.</p>"},{"location":"#more-than-a-retrieval-augmented-generation-rag-tool","title":"More Than a Retrieval Augmented Generation (RAG) Tool","text":"<p>Mojodex doesn't merely retrieve information from company data like RAG tools. It collaborates with users, performing tasks and enhancing work processes using the available data.</p>"},{"location":"#mojodex-is-tasks-oriented","title":"Mojodex is tasks-oriented","text":"<p>A task for Mojodex is any job activity requiring written content creation.</p> <p></p>"},{"location":"#why-an-open-source-digital-assistant-platform-for-enterprises","title":"Why an Open-source Digital Assistant Platform for Enterprises?","text":"<p>Mojodex was created to foster the adoption of digital assistants in businesses. The reasons for its open-source release are:</p> <ul> <li>Enable Enterprises to Building their own AI Assets: To support companies in creating their refined prompts and data wheel pipeline of high quality interaction with experts.</li> <li>On Premise &amp; Tailor-made: Providing an open-source platform for complete control over the software and data, development, hosting, and evolution.</li> <li>Boosting Internal Adoption: Business experts and tech team teamwork to tailor your company's digital assistants, tailored to their needs, fostering adoption.</li> </ul> <p>A highly valuable side effect of implementing a digital assistant platform is Process Optimization. Configuring their own digital assistant implies to optimizing a company's internal processes, promoting long-term development.</p>"},{"location":"#frequently-asked-questions-faqs","title":"Frequently Asked Questions (FAQs)","text":""},{"location":"#what-makes-the-mojodex-open-source-platform-different-from-other-gpt-chat-platforms-or-copilot-platforms","title":"What makes the Mojodex open-source platform different from other GPT chat platforms or copilot platforms?","text":"<p>Beyond Chat : Unlike platforms that are solely chat-based, Mojodex is task-oriented, using conversation to achieve the goal of completing tasks and producing deliverables.</p>"},{"location":"#what-are-the-benefits-of-using-mojodex-over-other-platforms","title":"What are the benefits of using Mojodex over other platforms?","text":"<ul> <li> <p>Never Locked: Being open-source, it allows for the creation of custom prompts and working on proprietary processes, rather than sending them to an uncontrolled platform.</p> </li> <li> <p>Ease of Integration: The assistant's API-centric architecture facilitates seamless integration with existing tools.</p> </li> </ul>"},{"location":"#how-about-the-data-privacy-and-security","title":"How about the data privacy and security?","text":"<ul> <li> <p>You own your data: Complete control over data flows, especially towards large language models, enabling users to connect their proprietary LLM solutions and fully manage the data stream.</p> </li> <li> <p>As secure as your infrastructure is: For sensitive data, hosting on personal infrastructure provides total control.</p> </li> </ul>"},{"location":"#what-can-i-do-with-the-data-generated-by-mojodex","title":"What can I do with the data generated by Mojodex?","text":"<p>Users own their data, allowing the construction of interaction datasets at an enterprise scale, which are invaluable for retraining on specific use cases.</p>"},{"location":"#can-i-use-open-source-llms-with-mojodex","title":"Can I use open-source LLMs with Mojodex?","text":"<p>Yes, Mojodex is designed to be compatible with open-source LLMs, allowing best of both worlds with the use of proprietary models through APIS and hosted open-source models. This may require some development work.</p>"},{"location":"getting-started/","title":"Welcome!","text":"<p>Mojodex is an open-source digital assistant platform to help companies and individuals build their own AI-powered assets.</p> <p>It's a complete platform to build, deploy and manage your very own digital assistants.</p> <p>It is designed to be task-oriented, configurable, and personalizable. Mojodex is API-centric, allowing for easy integration with other tools and is available as a web application, mobile application, and Chrome extension.</p>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>[\ud83e\uddd1\u200d\ud83d\udcbb Tech team]:  Install Plaform Core</p> <p>See the installation video guide here: https://youtu.be/86_S_cXhhTA</p> <p></p> <ul> <li>Optional [\ud83e\uddd1\u200d\ud83d\udcbb Tech team]: Build your local mobile app</li> </ul>"},{"location":"getting-started/#getting-started-easy-steps-to-get-started-with-mojodex","title":"Getting started: Easy steps to get started with Mojodex","text":"<p>Goal: Get a good understanding of the platform</p> <p>[\ud83e\uddd1\u200d\ud83e\udd1d\u200d\ud83e\uddd1 Whole Team]: Test the existing examples on the web app and the mobile app</p> <ol> <li> <p>Try the demo on your local install</p> <ul> <li>Prepare a meeting recap</li> <li>Write a LinkedIn Post</li> <li>Prepare a sales pitch</li> <li>Build good understanding of the platform</li> </ul> </li> <li> <p>Configure a Sales Assistant Example</p> <ul> <li>Configure your own sales assistant using the provided example</li> <li>Define the tasks the assistant will help with</li> <li>Learn how to iterate on the configuration of the platform</li> </ul> </li> </ol>"},{"location":"getting-started/#to-go-further-work-on-your-long-term-ai-strategy","title":"To go further: Work on your long term AI strategy","text":"<p>Goal: Build your company's future-proof investment with AI.</p> <p>[\ud83d\udc69\u200d\ud83d\udcbc\ud83e\uddd1\u200d\ud83d\udcbc Whole Team]: Define the high level goals and scope of the project \u2013 process optimization, reducing mental load, increase productivity, etc. \u2013 and the User Team</p> <p>[\ud83d\udc69\u200d\ud83d\udcbc\ud83e\uddd1\u200d\ud83d\udcbc Whole Team]: Define the metrics to measure the success of the project.</p> <p>[\ud83d\udc69\u200d\ud83d\udcbc\ud83e\uddd1\u200d\ud83d\udcbc Whole Team]: Define the tasks the assistant will help with</p> <p>Tip</p> <p>\ud83c\udf1f These steps require teamwork, and boost team ownership and adoption</p>"},{"location":"getting-started/#key-features","title":"Key Features","text":"<ul> <li> <p>Task-Oriented : Mojodex is designed to assist users by completing specific tasks, making it easier for the assistant to understand and fulfill user needs.</p> </li> <li> <p>Configurable : Tailored to various professional uses, allowing for role-specific task configurations (sales, recruitment, personal assistance, etc.).</p> </li> <li> <p>Personalizable : Builds a memory of user interactions and goals to improve task execution.</p> </li> <li> <p>Proactive : Independently manages tasks, freeing users to focus on other activities through a chat-independent architecture.</p> </li> <li> <p>Multiple User Interfaces : Includes a web application in this repository, an open-source mobile application, and a Chrome extension.</p> </li> <li> <p>API-Centric Back-End : Enables easy integration with other tools through a well-defined API exposure.</p> </li> <li> <p>Using OpenAI's GPT-4 Turbo : Accessible directly via OpenAI or through Azure's functionalities.</p> </li> </ul>"},{"location":"motivations/","title":"Why Mojodex?","text":"<p>\ud83c\udf1f Mojodex, is an Open-source Digital Assistant for Enterprise. </p>"},{"location":"motivations/#whats-unique","title":"\ud83d\udd0d What's Unique","text":"<ol> <li> <p>Mojodex is highly customizable, allowing enterprises to create text-based tasks that are directly aligned with their business workflows. Go beyond chat-based interfaces; get the work done.</p> </li> <li> <p>This user-friendly multi-interfaces platform is not just another tool; it's fully customizable for your daily operations. All-in-one, a webapp, a mobile app and a browser extension.</p> </li> <li> <p>You own it. Mojodex is open-source, meaning you can modify it to fit your needs and keep your data secure. Don't delegate your internal process to a third-party SaaS platform;</p> </li> </ol>"},{"location":"motivations/#why-now","title":"\ud83d\udd52 Why now?","text":"<p>Companies are looking to invest in their own AI assets \u2013 prompts, workflows, process \u2013 by crafting specialized tasks for their digital assistants. </p> <p>\ud83d\udca1 Integrating Mojodex is equivalent to creating the AI assets of the company.</p> <p>Mojodex stands out by turning each interaction into a valuable asset, fueling the data flywheel at the heart of your company's AI-powered processes. </p> <p>\ud83d\udca1 Using Mojodex means creating the data you need to train your future AI tools</p>"},{"location":"motivations/#open-source","title":"\ud83d\ude80 Open-source","text":"<p>What sets Mojodex apart is its full integration of AI-native open-source code and open-weights models. </p> <p>This synergy creates a first-of-its-kind, future-proof platform for building your company's digital assets.</p>"},{"location":"motivations/#mojodex-in-your-business-ecosystem","title":"\ud83c\udf10 Mojodex in your Business Ecosystem","text":"<p>\ud83d\ude80 It's time to elevate your business with an AI assistant that's built for the task at hand and the challenges ahead. Let's embark on this journey together, shaping a future where AI is not only powerful but also a trusted ally in the enterprise software landscape.</p>"},{"location":"design-principles/products/how_it_works/","title":"How Products work?","text":""},{"location":"design-principles/products/how_it_works/#free-trial","title":"Free trial","text":"<p>At onboarding, new users are asked to select a product category. This category will define the user's profile and will automatically affect them the free trial product of this category. This allows users to try the product for a limited time or a limited number of tasks through a tailored experience matching their profile.</p>"},{"location":"design-principles/products/how_it_works/#moving-on-with-other-products","title":"Moving on with other products","text":"<p>Any time, the user can be affected products: - manually by an admin using Backoffice APIs - automatically by the payment system when buying a product (see below)</p> <p>This allow users to keep a tailored experience matching their profile and needs.</p>"},{"location":"design-principles/products/how_it_works/#buying-a-product-using-an-implemented-payment-service","title":"Buying a product using an implemented payment service","text":""},{"location":"design-principles/products/how_it_works/#stripe","title":"Stripe","text":"<p>When the user wants to buy a product though Stripe, here is the flow:</p> <ol> <li>A Stripe session is created (<code>webapp/helpers/hooks/useCreateStripeCheckoutSession.ts</code>)</li> <li>The Backend route PUT <code>/purchase</code> (<code>backend/app/routes/purchase.py</code>) is called specifying the stripe_session_id. This route creates a new purchase that is not active yet.</li> <li>The user is redirected to the Stripe checkout page</li> <li>The user pays for the product and is redirected to Mojodex's success page</li> <li>Stripe uses the <code>new purchase</code> webhook to notify Mojodex that the purchase is successful: POST <code>/purchase</code> (<code>backend/app/routes/purchase.py</code>). This route activates the purchase by:</li> <li>deactivating any previous active subscription if bought product is a subscription </li> <li>associating and enabling the product's tasks to the user</li> </ol> <p>If the product bought is a subscription, it will be kept active and no Stripe webhook will be call as long as user's payments are up to date. If a payment fails, Stripe calls a webhook to handle the end of a purchase: POST <code>/subscription_end</code> (<code>backend/app/routes/purchase_end_stripe_webhook.py</code>).</p>"},{"location":"design-principles/products/whats_a_product/","title":"What's a product?","text":"<p>Product concept is used in Mojodex not only for billing purposes but also to define group of users depending on their profile and needs. Products and purchase are ways to provide each user with a personalized, adapted experience on Mojodex.</p>"},{"location":"design-principles/products/whats_a_product/#main-concepts","title":"Main concepts","text":""},{"location":"design-principles/products/whats_a_product/#product","title":"Product","text":"<p>In Mojodex, a product is set of tasks the user can execute on Mojodex. A product has:</p> <ul> <li>a label to identify it</li> <li>some display data to display on the user's interface in their language (name of the product)</li> <li>a status (active or inactive)</li> <li>free boolean status : flag to indicate if it's free or not</li> <li>a limit number of tasks the user can execute using this product</li> <li>a number of days of validity of the product, after which it expires</li> <li>an eventual ID that can be used to identify it in the payment system (Stripe or Apple implemented for now)</li> <li>a product_category to which it belongs</li> </ul> <p></p> <p>A product is refered as a subscription when: - it has no limit number of tasks - it has no number of days of validity In this case, the business model for this product might be a monthly subscription. The subscription is automatically renewed every month, as long as there is no payment default (specific REST API call, made through dedicated webhook for Stripe and Apple).</p> <p>A product is refered as a consumable when it is not a subscription.</p> <p>A product is refered as free trial when it has: - a limit : in number of days of validity OR in number of tasks - a free status</p> <p>A product category visible by users must have 1 and only 1 free trial product so that the automatic association can be made at onboarding. (see below part Affectation &gt; Free trial)</p>"},{"location":"design-principles/products/whats_a_product/#product-task","title":"Product Task","text":"<p>As mentioned above, a product defines a set of tasks the user can execute on Mojodex. A product task is a task that is part of a product. Those associations are stored in the dedicated DB table <code>md_product_task</code>.</p>"},{"location":"design-principles/products/whats_a_product/#product-category","title":"Product category","text":"<p>A product category is a category of products. It is used to group products together and suggest tageted products to the user corresponding to their profile. A product category has: - a label to identify it - an emoji to display on the user's interface - some display data to display on the user's interface in their language (name and description) - a visible boolean status : flag to indicate if it's visible or not from the user's interface at the time to choose a category - an implicit goal: This goal will be affected to the user account as their initial goal. This goal is then used in the assistant's prompt to drive the assistance by this goal.</p> <p></p>"},{"location":"design-principles/products/whats_a_product/#purchase","title":"Purchase","text":"<p>A purchase is the relation between a user and a product. It is created when a product is affected to a user, no matter if it's a free trial, a consumable or a subscription. The purchase object contains metadata about the purchase, such as dates, status, ids... The purchase will also be used to tag any user task execution to keep track of the user's activity.</p> <p></p>"},{"location":"design-principles/products/whats_a_product/#user-task","title":"User Task","text":"<p>When a new purchase is created (e.g. a product is affected to a user), the user is granted access to the tasks of the product. This creates an association between the user and each task of the product. This association is stored in the dedicated DB table <code>md_user_task</code>.</p>"},{"location":"design-principles/products/whats_a_product/#affectation","title":"Affectation","text":""},{"location":"design-principles/products/whats_a_product/#product-category-selection","title":"Product category selection","text":"<p>When a user creates an account, they go through a process we call \"onboarding\". During this process, the user is asked to select a product category. This category defines the user's profile and will be used to: - define their initial goal - affect them a free trial product - later suggest them adapted products</p> <p></p>"},{"location":"design-principles/products/whats_a_product/#free-trial","title":"Free trial","text":"<p>When a user selects a product category at onboarding, they are automatically affected a free trial product. A product category must have only 1 single free trial product. This free-trial product will be the one associated to the user at onboarding.</p>"},{"location":"design-principles/products/whats_a_product/#purchase-services","title":"Purchase services","text":"<p>Later, a user can: - be affected new products manually by an admin using backoffice APIs - buy a product through interface</p> <p>Important note: A user can't have 2 active subscriptions at the same time. If a user is affected with a new subscription, the previous one is automatically cancelled.</p> <p>Payment service implemented: Stripe</p>"},{"location":"design-principles/profiles/whats_a_profile/","title":"What is a profile?","text":"<p>Profile concept is used in Mojodex to define a group of users depending on their needs. Profiles and roles are ways to provide each user with a personalized, adapted experience on Mojodex.</p>"},{"location":"design-principles/profiles/whats_a_profile/#profile-vs-product","title":"Profile VS Product","text":"<p>The concept of profile has been introduced after notion of product. A profile and a product point exactly to the same object in database. A profile/role is just a vocabulary that matches better to a \"pre-set\" user configuration versus a product/purchase the user would buy on itself. A profile is generally pre-configured by an admin and assigned to a user through a role.</p>"},{"location":"design-principles/profiles/whats_a_profile/#main-concepts","title":"Main concepts","text":""},{"location":"design-principles/profiles/whats_a_profile/#profile","title":"Profile","text":"<p>The profile concepts are the same as the product concepts, knowing that: - a profile's \"free\" status is always true - a profile's n_tasks and days_validity limits are always null - product_stripe_id and product_apple_id are always null</p> <p>Finally, variables of a profile are:</p> <ul> <li>a label to identify it</li> <li>some display data to display on the user's interface in their language (name of the profile)</li> <li>a status (active or inactive)</li> <li>a profile_category to which it belongs</li> </ul>"},{"location":"design-principles/profiles/whats_a_profile/#profile-task","title":"Profile Task","text":"<p>As profile_task defines a set of tasks the user can execute on Mojodex. A profile task is a task that is part of a profile. Those associations are stored in the dedicated DB table <code>md_product_task</code>.</p>"},{"location":"design-principles/profiles/whats_a_profile/#profile-category","title":"Profile category","text":"<p>A profile category is a category of profile. It is used to group profiles together. A profile category has: - a label to identify it - an emoji to display on the user's interface - some display data to display on the user's interface in their language (name and description) - a visible boolean status : flag to indicate if it's visible or not from the user's interface at the time to choose a category if onboarding is done by user. - an implicit goal: This goal will be affected to the user account as their initial goal. This goal is then used in the assistant's prompt to drive the assistance by this goal.</p>"},{"location":"design-principles/profiles/whats_a_profile/#role","title":"Role","text":"<p>A role is the relation between a user and a profile. It is the equivalent to a purchase when speaking about products. It is created when a profile is affected to a user.</p>"},{"location":"design-principles/profiles/whats_a_profile/#user-task","title":"User Task","text":"<p>When a new role is created (e.g. a profile is affected to a user), the user is granted access to the tasks of the profile. This creates an association between the user and each task of the profile. This association is stored in the dedicated DB table <code>md_user_task</code>.</p>"},{"location":"design-principles/tasks/execute_task/","title":"Instruct Task Execution Workflow in Mojodex","text":"<p>This document provides an overview of the concept related to the task execution process in the Mojodex platform and describes the sequence of events that occur from the moment a user initiates a new task execution until the task is completed and the result is delivered.</p>"},{"location":"design-principles/tasks/execute_task/#main-concepts","title":"Main concepts","text":"<p>The task execution process involves several concepts matching database tables.</p>"},{"location":"design-principles/tasks/execute_task/#task","title":"Task","text":"<ul> <li>Task concept is fully described in this doc. Basically, a task is a some work the assistant can help the user with. A task is fully configurable. A task can be of type \"instruct\" or \"workflow\". <p>This documentation</p> </li> </ul>"},{"location":"design-principles/tasks/execute_task/#user-task","title":"User Task","text":"<ul> <li>Each user has its own set of tasks it can launch with Mojodex.  A <code>user_task</code> stands for the association between a user and a task. Those association are defined by user's product (detailled in a coming doc).</li> </ul>"},{"location":"design-principles/tasks/execute_task/#user-task-execution","title":"User Task Execution","text":"<ul> <li>A <code>user_task_execution</code> represents the instance of a task being executed by a user. It captures various details such as the start time and any relevant metadata pertaining to the execution of a specific task by a user.</li> </ul> <p>Note, sometimes refered as <code>task_execution</code> for short.</p>"},{"location":"design-principles/tasks/execute_task/#session","title":"Session","text":"<ul> <li>A <code>session</code> represents an interaction between the user and the assistant. It captures the messages exchanged between the user and the assistant, as well as the state of the conversation at any given time. A <code>user_task_execution</code> always needs a <code>session</code> for the user and its assistant to co-work on the task.</li> </ul> <p>Note: With existing interface, a <code>user_task_execution</code> has 1 <code>session</code>. 1 <code>session</code> can have multiple <code>user_task_execution</code>, for example using a more general chat with routing to specific tasks.</p>"},{"location":"design-principles/tasks/execute_task/#message","title":"Message","text":"<ul> <li>A <code>message</code> represents a single message exchanged between the user and the assistant within a session. It captures the content of the message, sender, timestamp of the message, and other relevant metadata depeding on the type of message. In the database, a <code>json</code> field is used to store the content of the message, allowing high flexibility regarding stored data.</li> </ul>"},{"location":"design-principles/tasks/execute_task/#produced-text","title":"Produced text","text":"<ul> <li>A <code>produced_text</code> represents the result of a task execution. It contains all versions of the result as references to <code>produced_text_version</code></li> </ul>"},{"location":"design-principles/tasks/execute_task/#produced-text-version","title":"Produced text version","text":"<ul> <li>A <code>produced_text_version</code> represents a version of the result of a task execution. It contains the content of the result and the date of the version.</li> </ul>"},{"location":"design-principles/tasks/execute_task/#task-execution-workflow","title":"Task execution workflow","text":"<p>The task execution workflow is a sequence of events that occur from the moment a user initiates a new task execution until the task is completed and the result is delivered. The workflow is described below.</p>"},{"location":"design-principles/tasks/execute_task/#1-user-task-execution-creation","title":"1. User Task Execution Creation","text":"<p>Creation of execution is done as soon as the user hits the card of the task they want to create.</p> <p></p> <p>This generates a call to PUT <code>/user_task_execution</code> to the backend (<code>backend/app/routes/user_task_execution.py</code>), specifying the <code>user_task</code> the user wants to execute. This call creates a User Task Execution instance in the database and a <code>session</code> if not already exists (which is the case in current Mojodex implementations).</p> <pre><code>from mojodex_core.entities.db_base_entities import MdUserTaskExecution\n[...]\nclass UserTaskExecution(Resource):\n    [...]\n    def put(self, user_id): \n        [...]\n        session_creation = self.session_creator.create_session(user_id, platform, \"form\")\n        [...]\n        session_id = session_creation[0][\"session_id\"]\n        [...]\n        task_execution = MdUserTaskExecution(user_task_fk=user_task_pk,\n                                                json_input_values=empty_json_input_values, session_id=session_id)\n        db.session.add(task_execution)\n        db.session.commit()\n</code></pre> <p>This call also returns the input fields to display to the user in the interface so that user have the instructions to start. Those input fields are the one defined in the task's json configuration file as <code>json_input</code>. <pre><code>return {**{\"user_task_execution_pk\": task_execution.user_task_execution_pk,\n                     \"json_input\": json_input,\n                     \"actions\": predefined_actions,\n                     \"text_edit_actions\" : recover_text_edit_actions(user_task_pk=user_task_pk)\n                     }, **session_creation[0]}, 200\n</code></pre></p> <p></p> <p></p>"},{"location":"design-principles/tasks/execute_task/#2-user-task-execution-start","title":"2. User Task Execution Start","text":"<p>From those instructions, there are 2 ways to start the task:</p>"},{"location":"design-principles/tasks/execute_task/#21-user-task-execution-start-from-filled-form","title":"2.1. User Task Execution Start from filled form","text":"<p>This is the method used in the web interface. The user fills the form and submit it. This generates a call to POST <code>/user_task_execution_run</code> to the backend (<code>backend/app/routes/user_task_execution_run.py</code>), specifying the <code>user_task_execution_pk</code> received at previous step and the values of filled form.</p> <p>Resource associated to the route updates the User Task Execution instance and instanciates a <code>Session</code>(<code>backend/app/models/session/session.py</code>).</p> <p>Finally, it launches in a parallel thread the start of the task by running session.<code>process_form_input</code> method.</p> <pre><code>[...]\nclass UserTaskExecutionRun(Resource):\n    [...]\n    def post(self, user_id):\n        [...]\n        user_task_execution.start_date = datetime.now()\n        db.session.commit()\n        [...]\n        from models.assistant.session_controller import SessionController\n        session = SessionController(user_task_execution.session_id)\n\n        def launch_process(session, app_version, platform, user_task_execution_pk, use_message_placeholder, use_draft_placeholder):\n            session.process_form_input( app_version, platform, user_task_execution_pk, use_message_placeholder=use_message_placeholder, use_draft_placeholder=use_draft_placeholder)\n            return\n        [...]\n        server_socket.start_background_task(launch_process, session, app_version, platform, user_task_execution_pk, use_message_placeholder, use_draft_placeholder)\n</code></pre> <p>The <code>SessionController</code> is the epicenter of task execution. The function <code>process_form_input()</code> will: - Asynchronously generate task execution title and summary - Prepare first assistant's response to the user.</p> <p></p>"},{"location":"design-principles/tasks/execute_task/#22-user-task-execution-start-from-user-message","title":"2.2. User Task Execution Start from user message","text":"<p>On the mobile app, the user sees the same instructions as in the web's form but is free to send to the assistant the first message they want. </p> <p>This first message generates a call to PUT <code>/user_message</code> (<code>backend/app/routes/user_message.py</code>) specifying the <code>user_task_execution_pk</code> received at previous step and the message content.</p> <p>This route can be called for any user message, at any step in the task execution process to send user's message to backend. If it appears the User Task Execution identified by the <code>user_task_execution_pk</code> is not started, it will start it.</p> <pre><code>[...]\nclass UserMessage(Resource):\n    [...]\n    def put(self, user_id):\n        [...]\n        user_task_execution = db.session.query(MdUserTaskExecution) \\\n            .join(MdUserTask, MdUserTaskExecution.user_task_fk == MdUserTask.user_task_pk) \\\n            .filter(MdUserTaskExecution.user_task_execution_pk == user_task_execution_pk) \\\n            .filter(MdUserTask.user_id == user_id) \\\n            .first()\n        [...]\n\n        if user_task_execution.start_date is None:\n            user_task_execution.start_date = datetime.now()\n            db.session.commit()\n        [...]\n</code></pre> <p>Once the User Task Execution is updated, the Resource will instanciate a <code>SessionController</code> object (<code>backend/app/models/assistant/session_controller.py</code>), responsible for managing user and assistant messages exchanges.</p> <p>Finally, it launched a parallel thread in which it runs method <code>process_chat_message</code> of <code>SessionController</code>.</p> <pre><code>[...]\nclass UserMessage(Resource):\n    [...]\n    def put(self, user_id):\n        [...]\n        session = SessionController(session_id)\n\n        session_message = {\"text\": db_message.message[\"text\"],\n                               \"message_pk\": db_message.message_pk,\n                               \"audio\": not \"text\" in request.form,\n                               \"user_task_execution_pk\": user_task_execution_pk,\n                               \"origin\": origin,\n                               \"home_chat_pk\": db_home_chat.home_chat_pk if db_home_chat else None,\n                               \"message_date\": message_date.isoformat(),\n                               \"platform\": platform,\n                               \"use_message_placeholder\": use_message_placeholder,\n                               \"use_draft_placeholder\": use_draft_placeholder}\n\n\n        server_socket.start_background_task(session.process_chat_message, \"user_message\", session_message)\n        [...]\n</code></pre> <p>The <code>process_chat_message</code> method will: - Check the message is a task execution message - Asynchronously generate task execution title and summary - Instanciate an appropriate <code>ChatAssistant</code> object depending of the type of the task - Call <code>generate_message()</code> of this assistant to generate the assistant's response to the user.</p> <pre><code>[...]\nclass SessionController:\n\n    [...]\n\n    def process_chat_message(self, message):\n\n        [...]\n\n        if \"message_pk\" not in message:\n            self._new_message(message, Message.user_message_key, \"user_message\")\n\n        [...]\n\n        if \"user_task_execution_pk\" in message and message[\"user_task_execution_pk\"] is not None:\n\n            [...]\n\n            server_socket.start_background_task(TaskExecutionTitleSummaryGenerator.generate_title_and_summary,\n                                                    user_task_execution.user_task_execution_pk, callback=callback)\n\n            [...]\n            # For now only task sessions\n            if user_task_execution.task.type == \"instruct\":\n                return self.__manage_instruct_task_session(self.platform, user_task_execution, use_message_placeholder,\n                                                           use_draft_placeholder)\n            else:\n                return self.__manage_workflow_session(self.platform, user_task_execution, use_message_placeholder,\n                                                      use_draft_placeholder)\n        [...]\n[...]\n</code></pre> <p></p>"},{"location":"design-principles/tasks/execute_task/#3-iterating-on-a-task","title":"3. Iterating on a task","text":"<p>The task execution process is an iterative process. The user and the assistant exchange messages until the user is satisfied with the produced result.</p> <p>When the assistant sends a message to ask for any precision or when they want to ask for an edition, the user can send a message through the chat interface to interact with the assistant.</p> <p>When the user sends a message during a task execution, the message is sent to the backend through a PUT <code>user_message</code> call and the same process as described in part 2.2 is repeated.</p> <p></p>"},{"location":"design-principles/tasks/whats_a_task/","title":"What's a task?","text":""},{"location":"design-principles/tasks/whats_a_task/#task","title":"Task","text":"<p>A task on Mojodex is a discrete piece of work, inspired by the JRC-Eurofound Tasks Framework and O*NET OnLine, representing various skills and specializations required to accomplish it.</p>"},{"location":"design-principles/tasks/whats_a_task/#what-does-executing-a-task-produces","title":"What does executing a task produces?","text":"<p>A text.</p> <p>Yes, it's that simple, and so powerful, because it can be any kind of text, and based on many types of inputs.</p> <p></p> <p>In this example, the <code>Result</code> tab contains the result of the execution of a task which helped me create the documentation of Mojodex. I can easily copy / paste the result to VS Code, adjust the text, fix mistakes and ship it in my repo.</p>"},{"location":"design-principles/tasks/whats_a_task/#why","title":"Why?","text":"<p>We build this \"task-centric\" assistant to provide the best help to the user, tailored to their needs. Technically, a task is described as a configuration file containing all information the assistant needs. This way, any expert can create a really specific task and the assistant will be able to guide the user through the process of accomplishing it in a conversational, seamless way.</p>"},{"location":"design-principles/tasks/whats_a_task/#mojodex-usage","title":"Mojodex usage","text":"<p>A Mojodex user has access to the task corresponding to their profile. This way, the assistant is completely tailored to the user's needs and can provide the best help.</p> <p></p> <p>On the web or mobile app interface, the user directly selects the task they want to accomplish. This makes it easy for the user to ask for the help they need without having to think about how to phrase their request. The assistant then guides them through the process, asking questions in a conversational way though a chat interface.</p> <p></p> <p>Once the assistant collected all the necessary information, it starts drafting the document resulting from the task. The user can then review and ask for any edit in the chat or directly modify the document.</p> <p></p>"},{"location":"design-principles/to-do_list/how_todo_works/","title":"How To-Do works?","text":""},{"location":"design-principles/to-do_list/how_todo_works/#to-do-extraction","title":"To-Do extraction","text":""},{"location":"design-principles/to-do_list/how_todo_works/#trigger","title":"Trigger","text":"<p>The To-Do extraction is triggered by scheduler through a job that is set to run every 10minutes. Every 10minutes, it sends a request to the <code>/extract_todo</code> endpoint on the background.</p> <p><code>scheduler/app/main.py</code> <pre><code>from scheduled_tasks.extract_todos import ExtractTodos\n[...]\nExtractTodos(600) # extract todos every 10 minutes\n[...]    \n</code></pre></p> <p>This background route will then select user task executions whose latest <code>md_produced_text_version</code> is between 10 and 20 minutes old. Those task executions are considered as \"done\" and their To-Do items will be extracted.</p> <p>The extraction process of To-Do items for selected task executions is launched in a parallel thread.</p> <pre><code>class ExtractTodos(Resource):\n\n    def post(self):\n        [...]\n        todos_creator = TodosCreator(user_task_execution_pk)\n        executor.submit(todos_creator.extract_and_save)\n        return {\"success\": \"Process started\"}, 200\n</code></pre>"},{"location":"design-principles/to-do_list/how_todo_works/#extraction-process","title":"Extraction process","text":"<p>The extraction process is done by the <code>TodosCreator</code> class. This class is instanciated with the <code>user_task_execution_pk</code> of the task execution to extract To-Do items from.</p> <p><code>background/app/models/todos/todos_creator.py</code> <pre><code>class TodosCreator:\n\n    # The instanciation is done by passing a key and not a DB object to avoid keeping a DB session open while a parallel thread using this object will be launched\n    def __init__(self, user_task_execution_pk):\n        self.user_task_execution_pk = user_task_execution_pk\n\n    # This is the method launched in a parallel thread\n    def extract_and_save(self):\n        collected_data = self._collect_data()\n        json_todos = self._extract(*collected_data)\n        [...]\n        self._save_to_db(todo['todo_definition'], todo['due_date'])\n\n    @with_db_session\n    def _collect_data(self, db_session):\n        # This method uses a dedicated db_session to access the database and retrieve all the data needed for the process\n        # It does not return any DB object but only required data to avoid keeping the DB session open\n        [...]\n        user = db_session.query(User) ...\n        [...]\n        return user.user_id, user.datetime_context, user.name, ...\n\n    def _extract(self, user_id, datetime_context, name, ...):\n        # This method processes the raw data provided by _collect_data to extract To-Do items\n        [...]\n\n    @with_db_session\n    def _save_to_db(self, description, due_date, db_session):\n         # create new todo\n            new_todo = MdTodo(\n                creation_date=datetime.now(),\n                description=description,\n                user_task_execution_fk=self.user_task_execution_pk\n            )\n            db_session.add(new_todo)\n            [...]\n            db_session.commit()\n            [...]\n</code></pre></p> <p>The method _extract() uses prompt <code>background/app/instructions/extract_todos.mpt</code>\u2013 filled with all tasks data to extract To-Dos out of completed task. Notable instructions of this prompt are:</p> <ul> <li> <p>Extraction instruction: To define what is a To-Do. <pre><code>[...]\nExtract any todo the user mentioned in the task as next steps they have to take.\nThose todos describes actions the user will have to do in the future. They cannot be passive.\n[...]\n</code></pre></p> </li> <li> <p>Explicitely-mentioned only instruction: To avoid any hallucination from the agent. <pre><code>[...]\nExtract ONLY next steps the user explicitly mentioned in the task.\n[...]\n</code></pre></p> </li> <li> <p>Assigned-only instruction: To avoid including To-Dos' that could be assigned to the user's contact in an email task or other participant mentioned in a meeting minutes, for example.</p> </li> </ul> <pre><code>[...]\nExtract ONLY next steps assigned to the user.\n[...]\n</code></pre> <p>The result of the prompt is a json list of dictionnary defining To-Do items.</p> <p><pre><code>{\n    \"todo_definition\": \"&lt;Definition as it will be displayed in the user's todo list.\n        The definition should help the user remember what was the original task.\n        Mention any name, company,... that can help them get the context.&gt;\",\n    \"mentioned_as_todo\": &lt;Did the user explicitly mentioned this as a todo? yes/no (in english)&gt;,\n    \"due_date\": \"&lt;Date at which the todo will be displayed in user's todo list. Format yyyy-mm-dd&gt;\"\n}\n</code></pre> This json is parsed and items are added to the database, related to the task.</p> <p>Once the To-Do items are extracted, their date format is checked and if it is valid, they are saved in the database.</p> <p></p>"},{"location":"design-principles/to-do_list/how_todo_works/#to-do-schedule","title":"To-Do Schedule","text":""},{"location":"design-principles/to-do_list/how_todo_works/#trigger_1","title":"Trigger","text":"<p>Another hourly trigger of the scheduler takes care of reorganizing user's To-Do list every night to keep it up-to-date.</p> <pre><code>from scheduled_tasks.reschedule_todos import RescheduleTodos\n[...]\nRescheduleTodos(3600) # reschedule todos every 1 hour\n[...]\n</code></pre> <p>This job calls background <code>/reschedule_todo</code> endpoint. This route select every To-Do item that is overdue and associated to a user whose local time is 1am. Those To-Do items are the ones that need to be rescheduled. The reschedule process of To-Do items is launched in a parallel thread.</p> <pre><code>class RescheduleTodo(Resource):\n\n    def post(self):\n        [...]\n            def reschedule_todos_by_batches(todo_pks):\n                for todo_pk in todo_pks:\n                    todos_rescheduler = TodosRescheduler(todo_pk)\n                    todos_rescheduler.reschedule_and_save()\n\n            executor.submit(reschedule_todos_by_batches, todo_pks)\n        [...]\n</code></pre>"},{"location":"design-principles/to-do_list/how_todo_works/#reschedule-process","title":"Reschedule process","text":"<p>The reschedule process is done by the <code>TodosRescheduler</code> class. This class is instanciated with the <code>todo_pk</code> of the To-Do item to reschedule.</p> <p><code>background/app/models/todos/todos_rescheduler.py</code> <pre><code>class TodosRescheduler:\n\n    todos_rescheduler_mpt_filename = \"instructions/reschedule_todo.mpt\"\n\n    # The instanciation is done by passing a key and not a DB object to avoid keeping a DB session open while a parallel thread using this object will be launched\n    def __init__(self, todo_pk):\n        self.todo_pk = todo_pk\n\n    # This is the method launched in a parallel thread\n    def reschedule_and_save(self):\n        [...]\n            collected_data = self._collect_data()\n            json_result = self._reschedule(*collected_data)\n            try:\n                # check reminder_date is a DateTime in format yyyy-mm-dd\n                reschedule_date=datetime.strptime(json_result['reschedule_date'], \"%Y-%m-%d\")\n            except ValueError:\n                [...]\n                return\n            self._save_to_db(json_result['argument'], reschedule_date)\n        [...]\n\n    # This method uses a dedicated db_session to access the database and retrieve all the data needed for the process\n    # It does not return any DB object but only required data to avoid keeping the DB session open\n    @with_db_session\n    def _collect_data(self, db_session):\n        [...]\n        todo, user_task_execution, user = db_session.query(Todo, UserTaskExecution, User)...\n        [...]\n        return user.user_id, user_task_execution.user_task_execution_pk, ...\n        [...]\n\n    @json_decode_retry(retries=3, required_keys=['reschedule_date', 'argument'], on_json_error=on_json_error)\n    def _reschedule(self, user_id, ...):\n        # This method processes the raw data provided by _collect_data to reschedule To-Do item\n\n    @with_db_session\n    def _save_to_db(self, argument, reschedule_date, db_session):\n        \"\"\"\n        Save new todo due-date in db\n        \"\"\"\n        try:\n            new_todo_scheduling = MdTodoScheduling(\n                todo_fk=self.todo_pk,\n                scheduled_date=reschedule_date,\n                reschedule_justification=argument\n            )\n\n            db_session.add(new_todo_scheduling)\n            db_session.commit()\n        except Exception as e:\n            raise Exception(f\"_save_to_db: {e}\")\n</code></pre></p> <p>The method _reschedule() uses prompt <code>background/app/instructions/reschedule_todo.mpt</code>\u2013 filled with data to reschedule To-Do including other To-Do items in To-Do list, number of times it has already been rescheduled...  This prompt main instruction is: <pre><code>[...]\nRegarding the TASK, TODO ITEM and USER TODO LIST, decide when to reschedule the TODO ITEM for later.\nThe task was currently scheduled for yesterday.\nProvide the new scheduled date.\n[...]\n</code></pre></p> <p>The result of the prompt is a json dictionnary defining the new due date of the To-Do item and some justification for the reschedule to help the LLM think step by step.</p> <pre><code>{\n    \"pros\": \"&lt;pros of rescheduling&gt;\",\n    \"cons\": \"&lt;cons of rescheduling&gt;\",\n    \"argument\": \"&lt;argument for chosen reschedule date&gt;\",\n    \"reschedule_date\": \"&lt;date at which the todo item should be rescheduled. Format yyyy-mm-dd&gt;\"\n}\n</code></pre> <p>The argument for the reschedule date will also be saved to notify the user of the reason for this new reschedule date.</p> <p></p>"},{"location":"design-principles/to-do_list/how_todo_works/#to-do-reminder","title":"To-Do Reminder","text":"<p>Every morning on weekday, the users that opted-in receive an email to remind them of their To-Do items due for the day. </p> <p>Note: this feature is available only if an email service is configured.</p>"},{"location":"design-principles/to-do_list/how_todo_works/#trigger_2","title":"Trigger","text":"<p>If an email service is configured, the To-Do reminder sending is triggered by scheduler through a job that is set to run every 1hour.</p> <pre><code>from scheduled_tasks.send_todo_daily_emails import SendTodoDailyEmails\n[...]\nif _check_emails_are_configured():\n    SendTodoDailyEmails(3600) # send todo daily emails every 1 hour (filtered by timezone)\n[...]\n</code></pre> <p>This job calls background <code>/event_generation</code> endpoint. This route select every user that opted-in for the To-Do reminder (todo_email_reminder=True) and whose local time is between 8am and 9am. Those users are the ones that need to receive the To-Do reminder email.</p> <p>The To-Do reminder email generation process is launched in a parallel thread.</p> <pre><code>class EventsGeneration(Resource):\n\n    def post(self):\n        [...]\n        def generate_events(user_ids, events_generator_class, **kwargs):\n                for user_id in user_ids:\n                    events_generator: EventsGenerator = events_generator_class(user_id, **kwargs)\n                    events_generator.generate_events()\n\n            executor.submit(generate_events, user_ids, events_generator_class, **kwargs)\n        [...]\n</code></pre>"},{"location":"design-principles/to-do_list/how_todo_works/#to-do-reminder-email-generation-process","title":"To-Do reminder email generation process","text":"<p>The To-Do reminder email generation process is done by the <code>TodoDailyEmailsGenerator</code> class. This class implements the <code>EventsGenerator</code> abstract class.</p> <p><code>background/app/models/events/todo_daily_emails_generator.py</code> <pre><code>class TodoDailyEmailsGenerator(EmailEventGenerator):\n\n    message_from_mojodex_email = \"mojodex_core/mails_templates/message_from_mojodex.html\"\n    todo_daily_email_text_mpt_filename = \"instructions/todo_daily_emails_text_prompt.mpt\"\n    todo_daily_email_type = \"todo_daily_email\"\n\n    # The instanciation is done by passing a user_id\n    def __init__(self, user_id):\n        self.user_id = user_id\n        super().__init__()\n\n    @with_db_session\n    def _collect_data(self, db_session):\n        try:\n            # This method uses a dedicated db_session to access the database and retrieve all the data needed for the process\n            user: User = db_session.query(User).get(self.user_id)\n            [...]\n\n            return user.email, ...\n        except Exception as e:\n            raise Exception(f\"_collect_data: {e}\")\n\n\n    def generate_events(self):\n        [...]\n            collected_data = self._collect_data()\n            email = collected_data[0]\n            email_json = self._generate_emails_text(*collected_data[1:]) # all except email\n\n            subject, body = email_json[\"subject\"], email_json[\"body\"]\n\n            with open(TodoDailyEmailsGenerator.message_from_mojodex_email, \"r\") as f:\n                template = Template(f.read())\n                body = template.render(mojodex_message=body, mojodex_webapp_url=os.environ[\"MOJODEX_WEBAPP_URI\"],\n                                        button_text=\"View To-do List\")\n            self.send_event(self.user_id,\n                            event_type=TodoDailyEmailsGenerator.todo_daily_email_type,\n                            subject=subject,\n                            body=body,\n                            email_address=email)\n\n        [...]\n\n\n    @json_decode_retry(retries=3, required_keys=[\"subject\", \"body\"], on_json_error=on_json_error)\n    def _generate_emails_text(self, ...):\n        [...]\n</code></pre></p> <p>The method _generate_emails_text() uses prompt <code>background/app/instructions/todo_daily_emails_text_prompt.mpt</code>\u2013 filled with data to generate the To-Do reminder email.  The text of the email must contain:</p> <ul> <li>The list of To-Do items due for the day</li> <li>The list of To-Do items that have been rescheduled this night by the assistant along with the reason for the reschedule</li> </ul> <p>The result of the LLM call is a json: <pre><code>{\n    \"subject\": \"&lt;Email subject&gt;\",\n    \"body\": \"&lt;Email body html formatted&gt;\"\n}\n</code></pre> Then, the method <code>send_event()</code>, defined in the <code>EmailEventGenerator</code> abstract class, sends the email to the user and logs the event in the database.</p> <p></p>"},{"location":"design-principles/to-do_list/how_todo_works/#user-actions-on-to-do-list","title":"User actions on To-Do list","text":"<p>Users can of course also act on their own To-Dos. For now, they can take 2 actions: - Delete a To-Do item, if it was not relevant to add it or the assistant made any mistake. As any application call, this call is made to the backend and the route is DELETE <code>/todo</code>.</p> <p>Note: an item is never deleted for real in the database. It is only marked as deleted so that it does not appear in the user's To-Do list anymore. This is to keep track of all the work the assistant has done. <code>backend/app/routes/todo.py</code> <pre><code>class Todos(Resource):\n    [...]\n    def delete(self, user_id):\n        [...]\n        todo.deleted_by_user = datetime.now()\n        db.session.commit()\n        [...]\n</code></pre></p> <ul> <li>Mark a To-Do as completed as soon as they don't need it anymore to remember of the work they have to do. As any application call, this call is made to the backend and the route is POST <code>/todo</code>. <code>backend/app/routes/todo.py</code> <pre><code>class Todos(Resource):\n    [...]\n    def post(self, user_id):\n        [...]\n        todo.completed = datetime.now()\n        db.session.commit()\n        [...]\n</code></pre></li> </ul> <p></p>"},{"location":"design-principles/to-do_list/whats_a_todo/","title":"What's a to-do?","text":""},{"location":"design-principles/to-do_list/whats_a_todo/#to-do","title":"To-Do","text":"<p>A To-Do item is some work the user has to tackle later.</p>"},{"location":"design-principles/to-do_list/whats_a_todo/#why","title":"Why?","text":"<p>This feature was thought to be the sparkle of proactivity in Mojodex. The idea is that your assistant manages your To-Do list seamlessly while you're tackling your task with its help.</p> <p>The vision of the todo-list feature is to manage itself without you having to think about it.</p>"},{"location":"design-principles/to-do_list/whats_a_todo/#mojodex-usage","title":"Mojodex usage","text":""},{"location":"design-principles/to-do_list/whats_a_todo/#generating-to-dos-items","title":"Generating to-dos items","text":"<p>When running a task on Mojodex, user may mention some next steps it has to take regarding this task.</p> <p>Example:  - get in touch in 3 days - send follow-up email - prepare a quote ...</p> <p>Once the task is done, the assistant will extract any mentionned next step, turn it into a to-do item and organize it in user's to-do list. </p>"},{"location":"design-principles/to-do_list/whats_a_todo/#to-do-list-extracted-from-achieved-tasks","title":"To-do list extracted from achieved tasks","text":"<p>This way, in their to-do list, users can access the list of any work to-do mentioned to their assistant while working on tasks. Users can manage their to-do list by deleting items that might not be relevant or marking some as completed as soon as they have worked on it.</p> <p>Each to-do item comes with a \"scheduled_date\", representing the deadline to achieve this work. This date is defined by the assistant at to-do creation.</p>"},{"location":"design-principles/to-do_list/whats_a_todo/#proactive-organization-organize-remind-the-user","title":"Proactive organization: Organize &amp; Remind the user","text":"<p>For users not to forget their pending work, a daily email is sent to them every morning containing:</p> <ul> <li>The list of to-do items due for the day</li> <li>An eventual summary of the re-organization work done by the assistant during the night</li> </ul> <p>Re-organization consists in re-scheduling for later any to-do items that should have been achieved by the day before but have not been marked as completed.</p>"},{"location":"design-principles/to-do_list/whats_a_todo/#user-action","title":"User action","text":"<p>User keeps control on their To-Do list by: - Deleting items that might not be relevant - Marking some as completed as soon as they have worked on it</p>"},{"location":"design-principles/to-do_list/whats_a_todo/#to-go-further","title":"To go further","text":"<p>Learn how the todo-list feature works in the technical documentation</p>"},{"location":"design-principles/workflows/execute_workflow/","title":"How <code>Workflows</code> are run?","text":"<p>This document provides an overview of the concept related to the workflow execution process in the Mojodex platform and describes the sequence of events that occurs from the moment a user initiates a new workflow execution until the workflow is completed and the result is delivered.</p>"},{"location":"design-principles/workflows/execute_workflow/#main-concepts","title":"Main concepts","text":"<p>The workflow execution process involves several concepts matching database tables.</p>"},{"location":"design-principles/workflows/execute_workflow/#workflow","title":"Workflow","text":"<ul> <li>Workflow concept is fully described in this doc. Basically, a worflow is a some complex process the assistant can help the user with. A workflow is fully configurable.</li> </ul>"},{"location":"design-principles/workflows/execute_workflow/#workflow-step","title":"Workflow Step","text":"<ul> <li>A <code>workflow_step</code> is a single step in a workflow. It is made of {input specification, execute method, output specification}. The execute method is the core of the step, it is where the step does its job. The input and output specification are used to validate the input and output of the step. A step can be run multiple times in a workflow, with different inputs and outputs.</li> </ul>"},{"location":"design-principles/workflows/execute_workflow/#user-workflow","title":"User Workflow","text":"<ul> <li>Each user has its own set of workflows it can launch with Mojodex.  A <code>user_workflow</code> stands for the association between a user and a workflow.</li> </ul>"},{"location":"design-principles/workflows/execute_workflow/#user-workflow-execution","title":"User Workflow Execution","text":"<ul> <li>A <code>user_workflow_execution</code> represents the instance of a workflow being executed by a user. It captures various details such as the start time and any relevant metadata pertaining to the execution of a specific workflow by a user.</li> </ul> <p>Note, sometimes refered as <code>workflow_execution</code> for short.</p>"},{"location":"design-principles/workflows/execute_workflow/#user-workflow-execution-step-execution","title":"User Workflow Execution Step Execution","text":"<ul> <li>A <code>user_workflow_execution_step_execution</code> represents the instance of a step being executed within a workflow execution. </li> </ul>"},{"location":"design-principles/workflows/execute_workflow/#session","title":"Session","text":"<ul> <li>A <code>session</code> represents an interaction between the user and the assistant. It captures the messages exchanged between the user and the assistant, as well as the state of the conversation at any given time. A <code>user_workflow_execution</code> always needs a <code>session</code> for the user and its assistant to co-work on the workflow.</li> </ul>"},{"location":"design-principles/workflows/execute_workflow/#message","title":"Message","text":"<ul> <li>A <code>message</code> represents a single message exchanged between the user and the assistant within a session. It captures the content of the message, sender, timestamp of the message, and other relevant metadata depeding on the type of message. In the database, a <code>json</code> field is used to store the content of the message, allowing high flexibility regarding stored data.</li> </ul>"},{"location":"design-principles/workflows/execute_workflow/#workflow-execution-workflow","title":"Workflow execution workflow","text":"<p>The workflow execution workflow is a sequence of events that occur from the moment a user initiates a new workflow execution until the workflow is completed. The workflow is described below.</p>"},{"location":"design-principles/workflows/execute_workflow/#1-user-workflow-execution-creation","title":"1. User Workflow Execution Creation","text":"<p>Creation of execution is done as soon as the user hits the card of the workflow they want to create.</p> <p></p> <p>This generates a call to PUT <code>/user_workflow_execution</code> to the backend (<code>backend/app/routes/user_workflow_execution.py</code>), specifying the <code>user_workflow</code> the user wants to execute. This call creates a User Workflow Execution instance in the database and a <code>session</code> if not already exists (which is the case in current Mojodex implementations).</p> <pre><code>from mojodex_core.entities.db_base_entities import MdUserWorkflowExecution\n[...]\nclass UserWorkflowExecution(Resource):\n    [...]\n    def put(self, user_id): \n        [...]\n        session_creation = self.session_creator.create_session(user_id, platform, \"form\")\n        [...]\n        session_id = session_creation[0][\"session_id\"]\n        [...]\n        db_workflow_execution = MdUserWorkflowExecution(\n                user_workflow_fk=user_workflow_pk,\n                session_id=session_id,\n                json_inputs=empty_json_input_values\n            )\n        db.session.add(db_workflow_execution)\n        db.session.commit()\n</code></pre> <p>This call also returns a json representation of the workflow, including json_inputs_spec to display to the user in the interface so that user have the instructions to start. Those input fields are the one defined in the workflows's json configuration file as <code>json_inputs_spec</code>.</p> <pre><code>return {\n           \"workflow_name_for_user\": \"&lt;workflow_name_for_user&gt;\",\n           \"workflow_definition_for_user\": \"&lt;workflow_definition_for_user&gt;\",\n           \"user_workflow_execution_pk\": &lt; pk &gt;,\n\"user_workflow_fk\": &lt; fk &gt;,\n\"steps\": [{\n              \"workflow_step_pk\": &lt; workflow_step_pk &gt;,\n          \"step_name_for_user\": \"&lt;step_name_for_user&gt;\",\n\"step_definition_for_user\": \"&lt;step_definition_for_user&gt;\"\n}, ...],\n\"validated_steps_executions\": [step_execution.to_json() for step_execution in\n                               self.past_accepted_steps_executions],\n\"session_id\": &lt; session_id &gt;,\n\"inputs\": &lt; json_inputs &gt;\n}\n</code></pre>"},{"location":"design-principles/workflows/execute_workflow/#2-user-workflow-execution-start","title":"2. User Workflow Execution Start","text":"<p>From those instructions, there are 2 ways to start the workflow:</p>"},{"location":"design-principles/workflows/execute_workflow/#21-user-workflow-execution-start-from-filled-form","title":"2.1. User Workflow Execution Start from filled form","text":"<p>This is the method used in the web interface. The user fills the form and submit it. This generates a call to POST <code>/user_workflow_execution</code> to the backend (<code>backend/app/routes/user_workflow_execution.py</code>), specifying the <code>user_workflow_execution_pk</code> received at previous step and the values of filled form.</p> <p>Resource associated to the route updates the User Workflow Execution instance and instanciate a Python object WorkflowExecution. Finally, it launches in a parallel thread the start of the workflow by running workflow.<code>run</code> method.</p> <pre><code>[...]\nclass UserWorkflowExecution(Resource):\n    [...]\n    def post(self, user_id):\n        [...]\n        db_workflow_execution.json_inputs = json_inputs\n        flag_modified(db_workflow_execution, \"json_inputs\")\n        db_workflow_execution.start_date = datetime.now()\n        db.session.commit()\n\n        workflow_execution = WorkflowExecution(user_workflow_execution_pk)\n\n        server_socket.start_background_task(workflow_execution.run)\n        [...]\n</code></pre> <p>The <code>WorkflowExecution</code> is the epicenter of workflow execution. The function <code>run()</code> will: - Determine what is the current step to run with what parameter and create the corresponding step execution object. - Run current step - Ask for user validation once the step is executed</p> <p></p> <p>The Workflow Execution detailled flow is described in part 3.</p>"},{"location":"design-principles/workflows/execute_workflow/#22-user-workflow-execution-start-from-user-message","title":"2.2. User Workflow Execution Start from user message","text":"<p>TODO - NOT IMPLEMENTED YET</p>"},{"location":"design-principles/workflows/execute_workflow/#3-workflow-execution","title":"3. Workflow Execution","text":"<p>A Workflow Execution is a Python object that manages the execution of a workflow. It corresponds to a <code>user_workflow_execution</code> in the database. It has a list of <code>WorkflowStepExecution</code> objects, one for each step of the workflow. The current step to run is determined by the _get_current_step() method.</p> <p>The entry point of the workflow execution is the <code>run</code> method of the <code>WorkflowExecution</code> class. This method is called in a parallel thread when the user starts the workflow execution or when a step needs to be executed (because of user validation or because of a user instruction to re-execute).</p> <pre><code>class WorkflowExecution:\n    [...]\n    def run(self):\n        [...]\n        if not self._get_current_step():\n            return\n        self._get_current_step().execute(self.initial_parameters, self._past_validated_steps_results, self.db_object.session_id)\n        self._ask_for_validation()\n    [...]\n</code></pre>"},{"location":"design-principles/workflows/execute_workflow/#31-determining-current_step","title":"3.1 Determining current_step","text":"<p>The _get_current_step() method determines the current step to run:</p> <pre><code>class WorkflowExecution:\n    [...]\n    def _get_current_step(self):\n        [...]\n            if self._current_step: # if current step already determined, return it\n                return self._current_step\n            if not self.validated_steps_executions: # no step validated yet, start from first step\n                self._current_step = self._generate_new_step_execution(self._db_workflow_steps[0], self.initial_parameters) # of first step\n                return self._current_step\n\n            last_validated_step_execution = self.validated_steps_executions[-1]\n\n            if len(self.validated_steps_executions) &gt; 1: # no dependency as it was the first step\n                db_dependency_step = [...]\n                # depency step is the workflow_step of step execution that created last_validated_step_execution inputs\n                # It is the workflow_step ranked just before the last_validated_step_execution's workflow_step in the workflow\n\n                # find last execution of dependency step\n                db_dependency_step_execution = [...]\n\n                # How many parameters have been executed and validated for last_validated_step_execution's workflow_step?\n                current_step_executions_count = [...]\n\n                # have all parameters resulting from db_dependency_step_execution been executed and validated?\n                if current_step_executions_count &lt; len(db_dependency_step_execution.result):\n                    current_parameter = db_dependency_step_execution.result[current_step_executions_count]\n                    self._current_step = self._generate_new_step_execution(last_validated_step_execution.workflow_step, current_parameter)\n                    return self._current_step\n\n            # else, generate new step execution of next step\n            next_step = [...]\n            if next_step is None:\n                return None # end of workflow\n            # else\n            self._current_step=self._generate_new_step_execution(next_step, last_validated_step_execution.result[0])\n            return self._current_step\n            [...]\n</code></pre>"},{"location":"design-principles/workflows/execute_workflow/#33-executing-a-step","title":"3.3 Executing a step","text":"<p>Executing a step consists in executing the step on a certain parameter as input. A socketio message is sent to client before starting execution to update the client interface.</p> <pre><code>class WorkflowExecution:\n    [...]\n    def execute(self, initial_parameter: dict, past_validated_steps_results: List[dict], session_id: str):\n        [...]\n            step_json = self.to_json()\n            step_json[\"session_id\"] = session_id\n            server_socket.emit('workflow_step_execution_started', step_json, to=session_id)\n            self.result = self.workflow_step.execute(self.parameter, self.get_learned_instructions(), initial_parameter, past_validated_steps_results)\n        [...]\n</code></pre>"},{"location":"design-principles/workflows/execute_workflow/#34-asking-for-validation","title":"3.4 Asking for validation","text":"<p>Once the step execution is done, the user is asked to validate the result. This is done by sending a socketio message to the client application: <pre><code>def _ask_for_validation(self):\n        [...]\n        step_execution_json = self._get_current_step().to_json()\n        step_execution_json[\"session_id\"] = self.db_object.session_id\n        server_socket.emit('workflow_step_execution_ended', step_execution_json, to=self.db_object.session_id)\n        [...]\n</code></pre></p>"},{"location":"design-principles/workflows/execute_workflow/#4-user-validation","title":"4. User validation","text":""},{"location":"design-principles/workflows/execute_workflow/#41-user-validates","title":"4.1. User validates","text":"<p>If the user validates the result of the run, the route POST <code>/user_workflow_execution_step_execution</code>is called with value <code>validated</code> set to <code>True</code>. This route updates the <code>user_workflow_execution_step_execution</code> instance in the database and triggers the next step execution with <code>workflow.run</code> in a dedicated thread. <pre><code>class UserWorkflowStepExecution(Resource):\n    [...]\n    def post(self, user_id):\n        [...]\n        workflow_execution = WorkflowExecution(user_workflow_execution.user_workflow_execution_pk)\n        if validated:\n            workflow_execution.validate_step_execution(user_workflow_step_execution_pk)\n            server_socket.start_background_task(workflow_execution.run)\n        [...]\n</code></pre></p>"},{"location":"design-principles/workflows/execute_workflow/#42-user-does-not-validate","title":"4.2. User does not validate","text":"<p>If the user does not validate the result of the run, the route POST <code>/user_workflow_execution_step_execution</code>is called with value <code>validated</code> set to <code>False</code>.  This route adds a system message in the workflow execution's session to store a view of the workflow state at this point in the conversation. This message contains the achieved step until current checkpoint and the current steps executions after current checkpoints (steps that can still be re-executed).</p> <p>Then, the user will send a message using common route PUT <code>user_message</code>. This message will be eventually transcripted if it was audio and transfer to a session through method <code>process_chat_message</code>.</p> <p>The process chat message will decode the message and send it to <code>WorflowResponseGenerator</code>located in <code>backend/app/models/session/assistant_message_generators</code>. This class will generate the assistant response to user request from on going workflow's conversation (including the system messages).</p> <p>The goal of the assistant is to capture the new user instruction to re-execute the step with the same input but a new orientation. To do that, the LLM can answer with 3 types of tags:</p> <ul> <li>: If the user asked the assistant to edit something in ACHIEVED STEPS, the assistant will explain why it is not possible to edit this past checkpoint steps. <li>: If the user is not clear enough in its request for re-execution, the assistant will ask for clarification until it gets a clear instruction. <li> coming along with : once the assistant caught the user instruction, it will respond by encapsulating the user instruction in a  tag and add a message to inform the user that the instruction has been taken into account into  tag. <p>Once the assistant capture the user instruction, it will: - Invalidate the step - Launch a new run of the workflow in a dedicated thread</p> <p>The invalidation method is as follow: <pre><code>class WorkflowExecution:\n    [...]\n    def invalidate_current_step(self, learned_instruction):\n        [...]\n        current_step_in_validation = self._get_last_step_execution() # the step execution we went to invalidate is the last one\n        current_step_in_validation.invalidate(self.db_object.session_id) # set validated to False in database and send socketio message to client\n\n        if current_step_in_validation.workflow_step.is_checkpoint: # if this step is the checkpoint, it is the one that will learn from this failure\n            current_step_in_validation.learn_instruction(learned_instruction)\n            return\n\n        # If the step in validation is not a checkpoint, find the previous one that is a checkpoint\n        checkpoint_step = self._find_checkpoint_step()\n        # for all step in self.validated_steps_executions after checkpoint_step, invalidate them\n        checkpoint_step_index = self.validated_steps_executions.index(checkpoint_step)\n        for validated_step in self.validated_steps_executions[checkpoint_step_index:]:\n            validated_step.invalidate(self.db_object.session_id)\n            # remove from validated_steps_executions\n            self.validated_steps_executions.remove(validated_step)\n\n        # checkpoint_step learns from this failure\n        checkpoint_step.learn_instruction(learned_instruction)\n</code></pre></p> <p></p>"},{"location":"design-principles/workflows/whats_a_workflow/","title":"What's a <code>worflow</code>?","text":"<p>It's a particular type of <code>Task</code>.</p> <p>By the way, the <code>What's a task</code> page example is a workflow, actually.</p> <p></p>"},{"location":"design-principles/workflows/whats_a_workflow/#whats-different-with-an-instruct-task","title":"What's different with an <code>instruct</code> task?","text":"<p>Workflows are tasks:</p> <ul> <li>composed of multiple steps</li> <li>orchestrated with code</li> </ul> <p>As a consequence of these differences, developers can make more customized tasks, with more complex user interactions and more interoperability with other programs through APIs.</p> <p>There are examples in the <code>mojodex_core/workflows/</code> directory.</p>"},{"location":"design-principles/workflows/whats_a_workflow/#differences-between-instruct-and-workflow-tasks","title":"Differences between <code>instruct</code> and <code>workflow</code> tasks","text":"<code>instruct</code> <code>workflow</code> Quick and direct task. Step-by-step process. Made of a simple interaction = message exchanges, between the assistant and the user. A step is code. Anything can be done in this code including complex actions as API calls. Uses the same prompt template for every task. User can visualize and take action on each step results. Example: <code>Write a poem</code>: The user gives a subject and a number of stanzas and the poem is written straight-forward by conversation btw user and assistant. Example: <code>Write a poem stanza by stanza</code>: The user gives a subject and a number of stanzas and the assistant writes 1 stanza, user can edit or ask for edition before moving on to the next one etc\u2026 API calls could also be done to enrich poem, associate images\u2026"},{"location":"design-principles/workflows/whats_a_workflow/#usage","title":"Usage","text":"<p>A user has access to the workflows in the same section as the new task creation:</p> <p></p> <p>Provide the first input required to launch the first step of the workflow</p> <p></p> <p>For each step, interact with your assistant depending on how it's been designed, here, we want the user to review and validate the chapters of the documentation </p> <p>Once the final step of the workflow is done, the user has access to the result.</p> <p></p>"},{"location":"design-principles/workflows/whats_a_workflow/#how-to-create-a-workflow","title":"How to create a <code>workflow</code>?","text":"<p>See the doc in <code>guides/workflows/new_workflow.md</code></p>"},{"location":"guides/","title":"Getting Started","text":"<p>This is a step-by-step guide for teams to get started with Mojodex. It is designed to help you understand the platform and how to use it effectively.</p>"},{"location":"guides/#1-set-up-a-small-team","title":"1. Set up a small team","text":"<ul> <li>Iterate and try existing pre-configurations of Mojodex</li> <li>Gain a sense of how Mojodex works</li> </ul>"},{"location":"guides/#2-work-internally-with-company-teams","title":"2. Work internally with company teams","text":"<ul> <li>Define jobs and tasks where Mojodex will be most helpful</li> <li>Collaborate with team members to build dedicated tasks</li> </ul>"},{"location":"guides/#3-deploy-mojodex-in-the-companys-environment","title":"3. Deploy Mojodex in the company's environment","text":"<ul> <li>Choose between private cloud, on-premise, or internal servers</li> </ul>"},{"location":"guides/#4-review-and-improve-tasks-regularly","title":"4. Review and improve tasks regularly","text":"<ul> <li>Tweak existing tasks based on team feedback</li> <li>Work with team members to go deeper into task customization</li> </ul>"},{"location":"guides/#5-create-new-tasks-tailored-to-each-teams-needs","title":"5. Create new tasks tailored to each team's needs","text":"<ul> <li>Start with generic tasks (80% of initial Mojodex usage)</li> <li>After 1-2 months, tailored tasks should represent 80% of usage</li> </ul>"},{"location":"guides/#6-gradually-refine-the-process","title":"6. Gradually refine the process","text":"<ul> <li>Continuously improve Mojodex's effectiveness for each team</li> <li>Adapt tasks to better suit the team's requirements</li> </ul>"},{"location":"guides/#what-level-of-effort-is-required-to-implement-a-digital-assistant-platform","title":"What level of effort is required to implement a digital assistant platform?","text":"<p>Here's a breakdown of what is required:</p> Effort Team Description Resources Medium Management Define the high level goals and scope of the project \u2013 process optimization, reducing mental load, increase productivity, etc. \u2013 and the User Team See the Guides Medium Management + User Team Define the metrics to measure the success of the project. See the Guides High User Team Define the tasks the assistant will help with. Step by Step Guide for Teamwork Low Tech Team Deploy the Mojodex platform. See install from GitHub in 3 steps Medium Tech Team + User Team Iterate on the configuration of the assistant. See the Sales Assistant Example"},{"location":"guides/azure-deployment/","title":"Azure deployment","text":""},{"location":"guides/azure-deployment/#services","title":"Services","text":"<p>To deploy Mojodex on Azure Cloud, here is a list of required services:</p>"},{"location":"guides/azure-deployment/#azure-container-registry","title":"Azure Container Registry","text":"<p>Your registry will contain the Docker images of Mojodex: - backend - background - webapp</p>"},{"location":"guides/azure-deployment/#app-service-plan","title":"App Service Plan","text":"<p>The App Service Plan will be useful to create 3 App Services - cf next section.</p>"},{"location":"guides/azure-deployment/#app-services","title":"App Services","text":"<p>3 App Services will be created: - backend - background - webapp</p>"},{"location":"guides/azure-deployment/#container-instances","title":"Container instances","text":"<p>A container instance will be created to run the scheduler.</p>"},{"location":"guides/azure-deployment/#storage-account-file-share","title":"Storage Account (File Share)","text":"<p>A storage account will be used as volume for the backend and background services. It will store users data.</p>"},{"location":"guides/azure-deployment/#postgresql-flexible-server","title":"PostgreSQL flexible server","text":"<p>A PostgreSQL flexible server will be used for Mojodex database.</p>"},{"location":"guides/azure-deployment/#deploying-on-azure-for-the-first-time","title":"Deploying on Azure for the first time","text":""},{"location":"guides/azure-deployment/#pre-requesites","title":"Pre-requesites","text":"<ul> <li>Install Azure CLI</li> <li>Login to your Azure account <pre><code>az login\n</code></pre></li> <li>Set your active subscription <pre><code>az account set --subscription &lt;subscription_id&gt;\n</code></pre></li> </ul> <p>To deploy on Azure for the first time, we've made a script for you. Here is the process:</p> <ol> <li>Check environment variables defined in <code>deployment/azure_env_variables</code> files. Set your secrets.</li> <li>Set your own models providers credentials in models confs files.</li> <li>In the script <code>deployment/azure_deployment_script.sh</code>, check that every names and sku fit your needs.</li> <li>Launch the script from deployment folder <pre><code>cd deployment\nsh azure_deployment_script.sh\n</code></pre></li> </ol> <p>You will be prompted for:  - DATABASE password - Scheduler secret Other secrets are defined in environment variables files.</p> <p>After the script is done, you may have to restart the services from the portal to ensure everything is up and running with full configuration. When everything is up, you can access the webapp from its url.</p>"},{"location":"guides/azure-deployment/#updating-the-existing-azure-deployment","title":"Updating the existing Azure deployment","text":"<p>The documentation to update your existing Azure deployment is available in <code>deployment/azure-deployment-commands.md</code> once you've run the first deployment script.</p>"},{"location":"guides/products/new_product/","title":"Create a new product","text":"<p>Read What's a product documentation before creating a new product.</p>"},{"location":"guides/products/new_product/#creating-a-product-category","title":"Creating a product category","text":"<ul> <li> <p>STEP 1: Create the json file <pre><code>cp ./docs/guides/products/product_category_spec.json ./docs/guides/products/products_json/my_product_category.json\n</code></pre> Fill the json values of my_product_category.json with the ones fitting your need for this product category.</p> </li> <li> <p>STEP 2: Add the product category to the database Replace <code>&lt;BACKOFFICE_SECRET&gt;</code> with your actual token and run the following command in your terminal</p> </li> </ul> <pre><code>curl -X 'PUT' \\\n  'http://localhost:5001/product_category' \\\n  -H 'Authorization: &lt;BACKOFFICE_SECRET&gt;' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d @./docs/guides/products/products_json/my_product_category.json\n</code></pre>"},{"location":"guides/products/new_product/#creating-a-product","title":"Creating a product","text":"<ul> <li>STEP 1: Create the json file <pre><code>cp ./docs/guides/products/product_spec.json ./docs/guides/products/products_json/my_product.json\n</code></pre></li> </ul> <p>Fill the json values of my_product.json with the ones fitting your need for this product.</p> <ul> <li>STEP 2: Add the product to the database Replace <code>&lt;BACKOFFICE_SECRET&gt;</code> and <code>&lt;product_category_pk&gt;</code> with the previously created category pk and run the following command in your terminal:</li> </ul> <pre><code>curl -X 'PUT' \\\n  'http://localhost:5001/product' \\\n    -H 'Authorization: &lt;BACKOFFICE_SECRET&gt;' \\\n    -H 'accept: application/json' \\\n    -H 'Content-Type: application/json' \\\n    -d @./docs/guides/products/products_json/my_product.json\n</code></pre> <p>Remember a product category must have 1 free trial product (as defined in the What's a product documentation). This product will be the one associated by default to users selecting the category at onboarding. If no free trial product is defined, the users will encounter an error at onboarding.</p>"},{"location":"guides/products/new_product/#associating-tasks-to-the-product","title":"Associating tasks to the product","text":"<p>Now that your product is created, you need to associate the tasks to the product. For each task you want to associate, run the following command in your terminal: <pre><code>curl -X 'PUT' \\\n  'http://localhost:5001/product_task_association' \\\n  -H 'Authorization: &lt;BACKOFFICE_SECRET&gt;' \\\n    -H 'accept: application/json' \\\n    -H 'Content-Type: application/json' \\\n    -d '{\n    \"datetime\": \"2024-02-14T11:00:00.000Z\",\n    \"product_pk\": &lt;product_pk&gt;,\n    \"task_pk\": &lt;task_pk&gt;\n}'\n</code></pre></p>"},{"location":"guides/products/new_product/#affecting-the-product-to-a-user","title":"Affecting the product to a user","text":""},{"location":"guides/products/new_product/#new-user","title":"New user","text":"<p>A new user ccreating an account on Mojodex will go through an onboarding process. During this process, the user will be asked to select a product category. This category will define the user's profile and will automatically affect them the free trial product of this category.</p>"},{"location":"guides/products/new_product/#existing-user","title":"Existing user","text":""},{"location":"guides/products/new_product/#manually-by-an-admin","title":"Manually by an admin","text":"<p>An admin can affect a product to a user using the backoffice APIs. To do so, run the following command in your terminal: <pre><code>curl -X 'PUT' \\\n  'http://localhost:5001/manual_purchase' \\\n  -H 'Authorization: &lt;BACKOFFICE_SECRET&gt;' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n  \"datetime\": \"2024-02-14T11:53:58.771Z\",\n  \"user_id\": \"&lt;user_id&gt;\",\n  \"product_pk\": &lt;product_pk&gt;,\n  \"custom_purchase_id\": \"string\"\n}'\n</code></pre></p> <p>Remember, a user can't have 2 active subscriptions at the same time. If a user is affected with a new subscription, the previous one is automatically cancelled.</p>"},{"location":"guides/products/new_product/#buying-a-product-using-an-implemented-payment-service","title":"Buying a product using an implemented payment service","text":"<p>The user can also buy a product using Stripe or Apple in-app purchase flow, detailed in the How it works documentation.</p>"},{"location":"guides/profiles/new_profile/","title":"Create a new profile","text":"<p>Read What's a profile documentation before creating a new profile.</p>"},{"location":"guides/profiles/new_profile/#creating-a-profile-category","title":"Creating a profile category","text":"<ul> <li> <p>STEP 1: Create the json file <pre><code>cp ./docs/guides/profiles/profile_category_spec.json ./docs/guides/profiles/profiles_json/my_profile_category.json\n</code></pre> Fill the json values of my_profile_category.json with the ones fitting your need for this profile category.</p> </li> <li> <p>STEP 2: Add the profile category to the database Replace <code>&lt;BACKOFFICE_SECRET&gt;</code> with your actual token and run the following command in your terminal</p> </li> </ul> <pre><code>curl -X 'PUT' \\\n  'http://localhost:5001/profile_category' \\\n  -H 'Authorization: &lt;BACKOFFICE_SECRET&gt;' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d @./docs/guides/profiles/profiles_json/my_profile_category.json\n</code></pre>"},{"location":"guides/profiles/new_profile/#creating-a-profile","title":"Creating a profile","text":"<ul> <li>STEP 1: Create the json file <pre><code>cp ./docs/guides/profiles/profile_spec.json ./docs/guides/profiles/profiles_json/my_profile.json\n</code></pre></li> </ul> <p>Fill the json values of my_profile.json with the ones fitting your need for this profile.</p> <ul> <li>STEP 2: Add the profile to the database Replace <code>&lt;BACKOFFICE_SECRET&gt;</code> and <code>&lt;profile_category_pk&gt;</code> with the previously created category pk and run the following command in your terminal:</li> </ul> <pre><code>curl -X 'PUT' \\\n  'http://localhost:5001/profile' \\\n    -H 'Authorization: &lt;BACKOFFICE_SECRET&gt;' \\\n    -H 'accept: application/json' \\\n    -H 'Content-Type: application/json' \\\n    -d @./docs/guides/profiles/profiles_json/my_profile.json\n</code></pre>"},{"location":"guides/profiles/new_profile/#associating-tasks-to-the-profile","title":"Associating tasks to the profile","text":"<p>Now that your profile is created, you need to associate the tasks to the profile. For each task you want to associate, run the following command in your terminal: <pre><code>curl -X 'PUT' \\\n  'http://localhost:5001/profile_task_association' \\\n  -H 'Authorization: &lt;BACKOFFICE_SECRET&gt;' \\\n    -H 'accept: application/json' \\\n    -H 'Content-Type: application/json' \\\n    -d '{\n    \"datetime\": \"2024-02-14T11:00:00.000Z\",\n    \"profile_pk\": &lt;profile_pk&gt;,\n    \"task_pk\": &lt;task_pk&gt;\n}'\n</code></pre></p>"},{"location":"guides/profiles/new_profile/#affecting-the-profile-to-a-user","title":"Affecting the profile to a user","text":""},{"location":"guides/profiles/new_profile/#manually-by-an-admin","title":"Manually by an admin","text":"<p>An admin can affect a profile to a user using the backoffice APIs. To do so, run the following command in your terminal: <pre><code>curl -X 'PUT' \\\n  'http://localhost:5001/manual_purchase' \\\n  -H 'Authorization: &lt;BACKOFFICE_SECRET&gt;' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n  \"datetime\": \"2024-02-14T11:53:58.771Z\",\n  \"user_id\": \"&lt;user_id&gt;\",\n  \"profile_pk\": &lt;profile_pk&gt;,\n  \"custom_purchase_id\": \"string\"\n}'\n</code></pre></p>"},{"location":"guides/sales_assistant_example/","title":"Sales Assistant Configuration Example","text":"<p>In this documentation, we will go through the process of configuring the Mojodex platform for a specific use case.</p> <p>Its adaptability to specific use cases is what makes Mojodex the perfect tool for businesses that want to create a digital assistant tailored to their needs while maintaining control over it.</p> <p>To illustrate the process, we will go through the Sales Assistant use case.</p> <p>The goal of the Sales Assistant is to help sales people to be more efficient in their daily tasks.</p> <p>We will start by defining the scope of the Sales Assistant and then describe the different tasks it can perform.</p>"},{"location":"guides/sales_assistant_example/#what-you-will-learn","title":"What you will learn","text":"<p>By the end, you will know how to: - lead discussions within your teams to define the Sales Assistant's scope - design the different tasks of the Sales Assistant - implement the configuration in your Mojodex instance - deploy and test the Sales Assistant</p>"},{"location":"guides/sales_assistant_example/#1-define-the-sales-assistant-scope","title":"1. Define the Sales Assistant Scope","text":"<p>In their job, sales people have to perform a lot of different tasks and work activities, as described in the O*NET OnLine - Sales Representatives \u2013 Detailed Job Description</p> <p>We want to select a subset of these tasks to facilitate with the Sales Assistant, to help sales people focus on their core activities.</p>"},{"location":"guides/sales_assistant_example/#teamwork-to-define-the-scope","title":"Teamwork to define the scope","text":"<p>To define the scope of the Sales Assistant, we will need to work with the sales team to understand their daily tasks and the challenges they face.</p> <p>We will need to ask them questions such as: - What are the most repeatable time-consuming tasks? - Where do you spend most of your time out of your core sales activities?</p> <p>\ud83d\udcc4 You can use the following template questionnaire to lead the discussion</p> <p>Sales Assistant Scope Template</p> <p>The result of this teamwork will provide a list of tasks that the team would like to facilitate.</p> <p>Assess their feasibility with Mojodex and prioritize them.</p> <p>Once you are ready, you can start to implement the Sales Assistant.</p> <p>We recommend to start with a few tasks and then iterate on the configuration.</p> <p>In the next section, you will find common sales assistant tasks that you can use as a starting point.</p>"},{"location":"guides/sales_assistant_example/#starting-point","title":"Starting point","text":"<p>We recommend the following tasks which are the most common and time-consuming for sales people:</p> <ul> <li>Meeting Recap: The Sales Assistant will help sales people to recap the meetings they had with their leads.</li> <li>Event Conversation Recap: The Sales Assistant will help sales people to recap the conversations they had with leads during events.</li> <li>Follow-up Email: The Sales Assistant will help sales people to write follow-up emails to leads.</li> </ul>"},{"location":"guides/sales_assistant_example/#2-designing-the-tasks","title":"2. Designing the tasks","text":"<p>Now that we have a list of tasks, we want to design how Mojodex will facilitate them.</p> <p>For each task, you now have a sentence that describes what the team is expecting the Sales Assistant to do.</p> <p>Use the following route to prepare a task in JSON format for each task: <pre><code>curl --location --request POST 'http://localhost:5001/task_json' \\\n--header 'Authorization: backoffice_secret' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\"datetime\": \"2024-02-14T17:49:26.545180\",\n\"task_requirements\": \"&lt;task_description&gt;\"\n}'\n</code></pre></p> <p>You will need those JSON files for the next step: implementation</p>"},{"location":"guides/sales_assistant_example/#3-implement-the-sales-assistant-configuration","title":"3. Implement the Sales Assistant Configuration","text":"<p>With the scope and tasks designed, we can implement the configuration in Mojodex.</p>"},{"location":"guides/sales_assistant_example/#31-setup-the-category","title":"3.1 Setup the category","text":"<p>First, we need to setup the category for the Sales Assistant.</p> <p>\u2139\ufe0f See the environment setup documentation to get your token: <code>.env.example</code></p> <p><code>BACKOFFICE_SECRET=&lt;your_token&gt;</code></p> <p>Replace <code>&lt;BACKOFFICE_SECRET&gt;</code> with your actual token and run the following command in your terminal <pre><code>curl -X 'PUT' \\\n  'http://localhost:5001/product_category' \\\n  -H 'Authorization: &lt;BACKOFFICE_SECRET&gt;' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{ \\\n  \"datetime\": \"2024-02-14T10:46:15.283Z\", \\\n  \"label\": \"string\", \\\n  \"displayed_data\": [ \\\n    { \\\n      \"language_code\": \"en\", \\\n      \"name_for_user\": \"Sales\", \\\n      \"description_for_user\": \"Boosting sales? I've got your back!\" \\\n    } \\ \n  ], \\\n  \"emoji\": \"\ud83d\udcbc\", \\\n  \"implicit_goal\": \"Drive revenue growth by mastering sales interactions and fostering lasting client relationships.\" \\\n}'\n</code></pre></p> <p>The terminal will return a response with the <code>product_category_pk</code>. We will need it for the next step.</p>"},{"location":"guides/sales_assistant_example/#32-setup-the-product","title":"3.2 Setup the product","text":"<p>Then, we need to setup the product for the Sales Assistant.</p> <p>Replace <code>&lt;BACKOFFICE_SECRET&gt;</code> and <code>&lt;product_category_pk&gt;</code> with the previously created category pk and run the following command in your terminal:</p> <pre><code>curl -X 'PUT' \\\n  'http://localhost:5001/product' \\\n    -H 'Authorization: &lt;BACKOFFICE_SECRET&gt;' \\\n    -H 'accept: application/json' \\\n    -H 'Content-Type: application/json' \\\n    -d '{\n  \"datetime\": \"2024-02-14T10:53:06.502Z\",\n  \"product_label\": \"sales_assistant\",\n  \"displayed_data\": [\n    {\n      \"language_code\": \"en\",\n      \"name\": \"Sales Assistant\"\n    }\n  ],\n  \"product_category_pk\": &lt;product_category_pk&gt;,\n  \"is_free\": true,\n  \"n_days_validity\": 99999,\n  \"n_tasks_limit\": null\n}'\n</code></pre> <p>We set a 99999 days (~273 years) duration for the product to avoid any expiration.</p>"},{"location":"guides/sales_assistant_example/#33-setup-the-tasks","title":"3.3 Setup the tasks","text":""},{"location":"guides/sales_assistant_example/#331-create-the-tasks","title":"3.3.1 Create the tasks","text":"<p>The tasks are described in the <code>tasks</code> folder of the repository. Each task is a JSON file that describes the task and its parameters.</p> <ul> <li>Meeting Recap: Meeting Recap</li> <li>Event Conversation Recap: Event Conversation Recap</li> <li>Follow-up Email: Follow-up Email</li> </ul> <pre><code>for task in tasks/*.json; do\n    curl -X 'PUT' \\\n        'http://localhost:5001/task' \\\n        -H 'Authorization: &lt;BACKOFFICE_SECRET&gt;' \\\n        -H 'accept: application/json' \\\n        -H 'Content-Type: application/json' \\\n        -d \"@$task\"\ndone\n</code></pre> <p>The terminal will return a response with the <code>task_pk</code> for each task. We will need it for the next step.</p>"},{"location":"guides/sales_assistant_example/#34-associate-the-tasks-to-the-product","title":"3.4 Associate the tasks to the product","text":"<p>For each task created, we need to associate it to the product.</p> <p>Replace <code>&lt;BACKOFFICE_SECRET&gt;</code> and <code>&lt;task_pk&gt;</code> with each previously created task pk and run the following command in your terminal as many times as necessary:</p> <pre><code>curl -X 'PUT' \\\n  'http://localhost:5001/product_task_association' \\\n  -H 'Authorization: &lt;BACKOFFICE_SECRET&gt;' \\\n    -H 'accept: application/json' \\\n    -H 'Content-Type: application/json' \\\n    -d '{\n    \"datetime\": \"2024-02-14T11:00:00.000Z\",\n    \"product_pk\": &lt;product_pk&gt;,\n    \"task_pk\": &lt;task_pk&gt;\n}'\n</code></pre>"},{"location":"guides/sales_assistant_example/#4-deploy-and-test-the-sales-assistant","title":"4. Deploy and test the Sales Assistant","text":"<p>Now, the final part is to provide access to the Sales Assistant to the sales team.</p>"},{"location":"guides/sales_assistant_example/#41-deployment-to-the-existing-users","title":"4.1 Deployment to the existing users","text":"<p>To do so, we will provide access the sales team accounts to the Sales Assistant product.</p> <p>Run the following command for each user identified by their email:</p> <p>In a terminal, run the following command:</p> <p>\u2139\ufe0f Replace <code>&lt;BACKOFFICE_SECRET&gt;</code> , <code>&lt;product_pk&gt;</code> and <code>&lt;user_email&gt;</code> with the actual values.</p> <pre><code>curl -X 'PUT' \\\n  'http://localhost:5001/manual_purchase' \\\n  -H 'Authorization: &lt;BACKOFFICE_SECRET&gt;' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n  \"datetime\": \"2024-02-14T11:53:58.771Z\",\n  \"user_email\": \"demo@example.com\",\n  \"product_pk\": &lt;product_pk&gt;,\n  \"custom_purchase_id\": \"demo\"\n}'\n</code></pre>"},{"location":"guides/sales_assistant_example/#42-new-sales-team-members","title":"4.2 New sales team members","text":"<p>For new sales team members, during the onboarding process, they will now have to choose the 'Sales Assistant' product, that we just created.</p>"},{"location":"guides/sales_assistant_example/#future-work","title":"Future work","text":"<ul> <li>Integration with the CRM</li> </ul>"},{"location":"guides/sales_assistant_example/sales_assistant_scope_template/","title":"Sales Assistant Team Guide","text":""},{"location":"guides/sales_assistant_example/sales_assistant_scope_template/#step-by-step-guide-to-defining-your-sales-assistants-scope","title":"Step-by-Step Guide to Defining Your Sales Assistant's Scope","text":""},{"location":"guides/sales_assistant_example/sales_assistant_scope_template/#introduction","title":"Introduction","text":"<p>This guide is designed to help sales teams collaborate effectively to define the scope of their Sales Assistant, ensuring it provides the best possible support by facilitating tasks through assisted work.</p>"},{"location":"guides/sales_assistant_example/sales_assistant_scope_template/#step-1-establish-the-teamwork-discussion-goal","title":"Step 1: Establish the Teamwork Discussion Goal","text":"<p>Clarify the objective of your discussion with the sales team: to identify tasks that the Sales Assistant can facilitate, enhancing focus on core sales activities.</p>"},{"location":"guides/sales_assistant_example/sales_assistant_scope_template/#step-2-prepare-for-the-discussion","title":"Step 2: Prepare for the Discussion","text":"<p>Assemble all necessary documents and data to inform the discussion, such as sales performance metrics and current workflow analyses.</p>"},{"location":"guides/sales_assistant_example/sales_assistant_scope_template/#step-3-conduct-the-teamwork-discussion","title":"Step 3: Conduct the Teamwork Discussion","text":"<p>Facilitate a comprehensive meeting with the sales team to explore their daily activities and pinpoint tasks that could benefit from the support of the Sales Assistant. Utilize the following questions to guide the discussion:</p> <ul> <li>\"What are the most repetitive tasks that you encounter daily, and how do you feel about them?\"</li> <li>\"Which non-core sales activities take up a significant portion of your time?\"</li> <li>\"Are there specific tasks during the sales process where you feel overwhelmed or that could be streamlined?\"</li> <li>\"What kind of information do you find yourself repeatedly searching for during your workday?\"</li> <li>\"Can you identify any tasks that, while necessary, distract you from engaging with clients and closing deals?\"</li> <li>\"How much time do you spend on administrative work such as data entry, scheduling meetings, or writing emails?\"</li> <li>\"What are the common bottlenecks in your workflow that slow down the sales process?\"</li> <li>\"Are there any tools or resources you wish you had at your disposal to make your job easier?\"</li> <li>\"Which part of the sales process do you think has the most room for improvement in terms of efficiency?\"</li> <li>\"What are the tasks that you believe require your personal touch, and which ones could potentially be handled by an assistant?\"</li> </ul>"},{"location":"guides/sales_assistant_example/sales_assistant_scope_template/#step-4-document-the-findings","title":"Step 4: Document the Findings","text":"<p>Record all tasks and challenges identified during the discussion, ensuring every team member's input is captured.</p>"},{"location":"guides/sales_assistant_example/sales_assistant_scope_template/#step-5-analyze-categorize-and-prioritize-tasks","title":"Step 5: Analyze, Categorize, and Prioritize Tasks","text":"<p>Review the documented tasks and categorize them by nature and frequency. Instead of looking for automation opportunities, assess how Mojodex can assist and facilitate these tasks.</p>"},{"location":"guides/sales_assistant_example/sales_assistant_scope_template/#step-6-develop-a-prioritization-methodology","title":"Step 6: Develop a Prioritization Methodology","text":"<p>Evaluate the facilitation potential of each task using key metrics such as time saved, error reduction, and sales impact. Create a table to visualize the assessment, like the example below:</p> Task Frequency Time Saved Error Reduction Sales Impact Facilitation Potential Priority Qualifying Leads Daily High Medium High High 1 Meeting Recap Weekly Medium High Medium High 2 Follow-up Email Daily High Low High Medium 3 Event Conversation Recap Monthly Low Medium Low Medium 4"},{"location":"guides/sales_assistant_example/sales_assistant_scope_template/#step-7-describe-each-task-in-structured-paragraph","title":"Step 7: Describe each task in structured paragraph","text":"<p>Now, use the following template to describe each task: <pre><code>You are the sales assistant of the user. The user needs help to (achieve/do/perform) [...]. The user needs this help in the following situation: [...]. You will need the following informations to proceed: [...]. The result of the task is a[{document_type}]\n</code></pre></p> <p>You can add details such as tone, style or format of the document if that's relevant for the task.</p> <p>This detailed paragraph is the entry point for the team in charge of the implementation to create the tasks.</p>"},{"location":"guides/sales_assistant_example/sales_assistant_scope_template/#step-8-obtain-team-approval-and-finalize-the-scope","title":"Step 8: Obtain Team Approval and Finalize the Scope","text":"<p>Present the prioritized list to the sales team for validation and finalize the scope based on their consensus. This finalized scope will direct the configuration of the Sales Assistant within Mojodex.</p> <p>By following this structured approach, you will be equipped with all the information to prepare a Sales Assistant that is precisely tailored to support and facilitate their most impactful tasks.</p>"},{"location":"guides/tasks/example/","title":"Task creation example","text":"<p>Let's say you want to create a specific task for your assistant. Here is an example of how to do it.</p> <p>We take a fictional example of a salesperson, Mia, who needs to assistance to refine her sales pitch.</p>"},{"location":"guides/tasks/example/#crafting-the-perfect-sales-pitch-with-mojodex","title":"Crafting the Perfect Sales Pitch with Mojodex","text":""},{"location":"guides/tasks/example/#context","title":"Context","text":"<p>In the bustling heart of a startup district, I recently crossed paths with Mia, a passionate salesperson navigating the turbulent seas of entrepreneurship. Over coffee and conversations, Mia confided in me her struggles. Amidst the dynamic landscape of ever-evolving offers, she found herself grappling with a persistent dilemma - how to keep her pitch razor-sharp without succumbing to the dreaded \"white page syndrome.\"</p>"},{"location":"guides/tasks/example/#understanding-the-process","title":"Understanding the Process","text":"<p>As we delved deeper, Mia unveiled the anatomy of her sales pitch:</p> <ul> <li> <p>Identifying the Problem: Articulating the core issue her company and product address.</p> </li> <li> <p>Presenting the Solution: Conveying how her offering tackles the identified problem.</p> </li> <li> <p>Highlighting Uniqueness: Showcasing what sets her company and product apart from competitors.</p> </li> <li> <p>Defining the Target Market: Painting a vivid picture of the ideal customer.</p> </li> </ul> <p>Additionally, Mia emphasized the need for brevity, stressing that her pitch must be succinct yet captivating, always concluding with a compelling question to spark dialogue.</p>"},{"location":"guides/tasks/example/#crafting-the-task","title":"Crafting the Task","text":"<p>Eager to assist Mia in her quest for the perfect pitch, I set out to create a tailored task on Mojodex. Drawing from our conversation, I meticulously crafted a task specification:</p>"},{"location":"guides/tasks/example/#task-specification","title":"Task Specification","text":"<pre><code>{\n    \"platforms\": [\n        \"mobile\",\n        \"webapp\"\n    ],\n    \"task_type\": \"instruct\",\n    \"predefined_actions\": [],\n    \"task_displayed_data\": [\n        {\n            \"language_code\": \"en\",\n            \"name_for_user\": \"1 Minute Pitch\",\n            \"definition_for_user\": \"Prepare a 1 minute pitch to briefly present your company and product\",\n            \"json_input\": [\n                {\n                    \"input_name\": \"company_and_product_informations\",\n                    \"description_for_user\": \"Let's make a great pitch!\",\n                    \"description_for_system\": \"Information about the company and product (ex: company background, product, target market, unique selling points)\",\n                    \"placeholder\": \"What problem are you solving? How do you solve it? What makes you different from other solutions? Who is your ideal customer?\",\n                    \"type\": \"text_area\"\n                }\n            ]\n        }\n    ],\n    \"name_for_system\": \"create_one_minute_pitch\",\n    \"definition_for_system\": \"The user needs assistance to create a 1-minute pitch for presenting their company and product\",\n    \"final_instruction\": \"Write a 1-minute pitch to briefly present the company and product; finish with a question to engage conversation.\",\n    \"output_format_instruction_title\": \"1 MINUTE PITCH - COMPANY NAME\",\n    \"output_format_instruction_draft\": \"PITCH CONTENT\",\n    \"output_type\": \"document\",\n    \"icon\": \"\ud83c\udfa4\",\n    \"infos_to_extract\": [\n        {\n            \"info_name\": \"problem_solved\",\n            \"description\": \"The problem the company and product are solving\"\n        },\n        {\n            \"info_name\": \"solution\",\n            \"description\": \"How the company and product solve the problem\"\n        },\n        {\n            \"info_name\": \"unique_selling_points\",\n            \"description\": \"What makes the company and product different from other solutions\"\n        },\n        {\n            \"info_name\": \"target_market\",\n            \"description\": \"The target market represented by an ideal customer description\"\n        }\n    ],\n    \"result_chat_enabled\": true\n}\n</code></pre> <p>Note how:</p> <ul> <li> <p>The infos_to_extract lists all the information Mia - and now her assistant - needs to craft her pitch.</p> </li> <li> <p>The final_instruction provides a clear directive to the assistant, ensuring the pitch is concise and ends with a question as Mia requested.</p> </li> <li> <p>The user data are clear so that Mia easily finds the task and knows what to expect.</p> </li> </ul> <p>With this JSON file carefuly crafted, I just need to use the REST API to update the task list in the database.</p> <p>\u2139\ufe0f You can see how to do this in the new_task section</p>"},{"location":"guides/tasks/example/#tweak-it-until-the-user-love-it","title":"Tweak it until the user love it","text":"<p>After a couple tries, Mia and I decided to tweak it a bit. We added a twist to the <code>\"final_instruction\"</code> to fit best with Mia's preferences.</p> <p>\u2139\ufe0f To update a task, refer to the backend REST API</p>"},{"location":"guides/tasks/example/#conclusion","title":"Conclusion","text":"<p>With the task configuration complete, I eagerly shared it with Mia through Mojodex.</p> <p>Now armed with a personalized tool perfectly aligned with her needs in her pocket with her Mojodex Mobile, Mia can effortlessly craft compelling pitches, leaving behind the days of writer's block and embracing the art of persuasive communication with confidence.</p>"},{"location":"guides/tasks/new_task/","title":"Create a new instruct task","text":""},{"location":"guides/tasks/new_task/#technical-definition","title":"Technical definition","text":"<p>A task is a JSON object that contains all necessary information to render it in the app and to guide the assistant through the process of drafting the document resulting from the task. You can find a template of a task in the file <code>task_spec.json</code> in this repository.</p> <p>Let's break this specification down with \"meeting_minutes\" task as an example.</p>"},{"location":"guides/tasks/new_task/#task-type","title":"Task Type","text":"<p><pre><code>\"task_type\": \"instruct\"\n</code></pre> The type of the task. Can be \"workflow\" or \"instruct\". A workflow is a task that requires multiple steps, executed as code, to be completed. See dedicated <code>new_workflow</code> documentation for more information on how to create a workflow.</p>"},{"location":"guides/tasks/new_task/#platforms","title":"Platforms","text":"<p><pre><code>\"platforms\": [\"mobile\"]\n</code></pre> Platforms on which the task is available. Can be \"webapp\", \"mobile\" or both.</p>"},{"location":"guides/tasks/new_task/#system-information","title":"System information","text":"<p><pre><code>\"name_for_system\": \"prepare_meeting_minutes\",\n\"definition_for_system\": \"The user needs assistance to prepare a meeting minutes\"\n</code></pre> These fields are used by the system to defined tasks in prompts. name_for_system should be snake_case.</p>"},{"location":"guides/tasks/new_task/#final-instruction","title":"Final instruction","text":"<p><pre><code>\"final_instruction\": \"Write a meeting minutes in the form of bullet points\"\n</code></pre> This is the final instruction provided to the assistant prompt. It contains all instruction the assistant will follow to draft the document. It ends with an infinitive verb sentence as if it was an order to the assistant.</p>"},{"location":"guides/tasks/new_task/#output-format","title":"Output format","text":"<p><pre><code>\"output_format_instruction_title\": \"SHORT CONTEXT - DATE OF THE DAY\",\n\"output_format_instruction_draft\": \"CONTENT OF THE MEETING MINUTES\"\n</code></pre> These fields are used to define the format of the document resulting from the task. The assistant will use these instructions to format the document title and content.</p>"},{"location":"guides/tasks/new_task/#output-type","title":"Output type","text":"<p><pre><code>\"output_type\": \"meeting_minutes\"\n</code></pre> This field is used to define the type of document resulting from the task. It is used to enable special edition features once the document is ready. The value should match one existing in table 'md_text_type' of your database, if it does not, will be created.</p>"},{"location":"guides/tasks/new_task/#icon","title":"Icon","text":"<p><pre><code>\"icon\": \"\ud83d\udcdd\"\n</code></pre> The icon displayed in the app to represent the task.</p>"},{"location":"guides/tasks/new_task/#task-displayed-data","title":"Task displayed data","text":"<p><pre><code>\"task_displayed_data\": [\n    {\n        \"language_code\": \"en\", \n        \"name_for_user\": \"Meeting Recap\",\n        \"definition_for_user\": \"Get a simple summary and next steps for your meeting\",\n        \"json_input\": [  \n            {\n                \"input_name\": \"meeting_informations\",\n                \"description_for_user\": \"How was your meeting?\",\n                \"description_for_system\": \"Informations the user gave about the meeting (ex: participants, date, key topics, followup actions...)\",\n                \"placeholder\": \"Record a quick summary of what was discussed.\",\n                \"type\": \"text_area\"\n            }\n        ]\n    },\n    {\n        \"language_code\": \"fr\",\n        \"name_for_user\": \"R\u00e9capitulatif de R\u00e9union\",\n        \"definition_for_user\": \"Obtenez un r\u00e9capitulatif simple de votre r\u00e9union\",\n        \"json_input\": [\n            {\n                \"description_for_system\": \"Informations que l'utilisateur a fournies sur la r\u00e9union (ex : participants, date, sujets cl\u00e9s, actions de suivi...)\",\n                \"description_for_user\": \"Comment s'est pass\u00e9e votre r\u00e9union ?\",\n                \"input_name\": \"informations_reunion\",\n                \"placeholder\": \"Enregistrez un bref r\u00e9sum\u00e9 de ce qui a \u00e9t\u00e9 discut\u00e9.\",\n                \"type\": \"text_area\"\n            }\n        ]\n    }\n]\n</code></pre> This field contains all data displayed to the user in the app. It is an array of objects, each object representing a language. You can add as many languages as you want but you have to define at least english as it will be used as a fallback if the user's language is not available. The object contains the following fields: - language_code: the language code of the language - name_for_user: the name of the task in the language as it will be displayed to the user - definition_for_user: the definition of the task in the language as it will be displayed to the user - json_input: an array of objects, each object representing an information the user has to provide to the assistant when starting a new task.      - On the web app, it will be displayed as a form, one input per object.      - On the mobile app, it will be displayed in a chat as questions.     Each object contains the following fields:         - input_name: the name of the input as it will be used in the assistant prompt         - description_for_user: the description of the input as it will be displayed to the user         - description_for_system: the description of the input as it will be used in the assistant prompt         - placeholder: the placeholder of the input as it will be displayed to the user         - type: the type of the input. Can be only \"text_area\" for now.</p> <p>Note: For mobile use to remain interface friendly, we recommend to keep the number of inputs to 1. If the assistant needs to ask more than one question, it will do it in a conversational way.</p>"},{"location":"guides/tasks/new_task/#infos-to-extract","title":"Infos to extract","text":"<p><pre><code>\"infos_to_extract\": [\n    {\n        \"info_name\": \"key_topics\",\n        \"description\": \"Key topics discussed in the meeting\"\n    },\n    {\n        \"info_name\": \"participants\",\n        \"description\": \"Participants of the meeting\"\n    },\n    {\n        \"info_name\": \"date_of_meeting\",\n        \"description\": \"Date of the meeting\"\n    },\n    {\n        \"info_name\": \"followup_actions\",\n        \"description\": \"Followup actions if any\"\n    }\n]\n</code></pre> This field contains all the information the assistant needs to collect from the user before drafting the document. It is an array of objects, each object representing an information. Each object contains the following fields: - info_name: the name of the information as it will be used in the assistant prompt - description: the description of the information as it will be used in the assistant prompt</p>"},{"location":"guides/tasks/new_task/#predefined_actions","title":"predefined_actions","text":"<p><pre><code>\"predefined_actions\": [\n    {\n        \"task_pk\": &lt;pk of the task to chain&gt;,\n        \"displayed_data\": [\n            {\n                \"language_code\": \"en\",\n                \"data\": {\n                    \"name\": \"Send a follow-up email\", # name of the predefined action\n                    \"button_text\": \"Send email\", # text displayed on the button of the predefined action\n                    \"message_prefix\": \"Prepare a follow-up email to send this meeting minutes to the participants: \" # prefix of the message that will be sent to the assistant in behalf of the user to start the task. It will be concatenated with the produced_text of the previous task.\n                }\n            }\n        ]\n    }\n]\n</code></pre> Predefined Actions in Mojodex allow for chaining Task Executions. This feature is currently available only on the mobile app. It enables the execution of a subsequent task using the result of the previous task, maintaining the same context.</p>"},{"location":"guides/tasks/new_task/#result_chat_enabled","title":"result_chat_enabled","text":"<p><pre><code>\"result_chat_enabled\": true\n</code></pre> This field is used to enable the chat at the end of the task, once produced_text has been generated, to let user give instruction to edit the produced_text. It is by default true. On instruct tasks, it is recommended to keep it true.</p>"},{"location":"guides/tasks/new_task/#how-to-create-a-new-instruct-task","title":"How to create a new instruct task?","text":"<p>Let's create your first task on Mojodex.</p> <p>From the root of the repository.</p> <p>STEP 1: Create the json file <pre><code>cp ./docs/configure_assistant/tasks/task_spec.json ./docs/configure_assistant/tasks/tasks_json/my_task.json\n</code></pre></p> <p>Fill the json values of my_task.json with the ones fitting your need for this task.  You can get helped by using the dedicated route so that GPT-4 generates a first json for you from your requirements. <pre><code>curl --location --request POST 'http://localhost:5001/task_json' \\\n--header 'Authorization: backoffice_secret' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\"datetime\": \"2024-02-14T17:49:26.545180\",\n\"task_requirements\": \"You are the sales assistant of the user. The user needs help to (achieve/do/perform) [...]. The user needs this help in the following situation: [...]. You will need the following informations to proceed: [...]. The result of the task is a[{document_type}]\"\n}'\n</code></pre></p> <p>STEP 2: Add the task to the database <pre><code>curl --location --request PUT 'http://localhost:5001/task' \\\n--header 'Authorization: backoffice_secret' \\\n--header 'Content-Type: application/json' \\\n--data @my_task.json\n</code></pre> This command calls the backend REST API to create the task in the database and returns the primary key of the task. You will need this primary key in next step.</p> <p>STEP 3: Associate the task to your user though a product.</p> <p>Default user <code>demo@example.com</code> is associated with default product <code>demo</code> with pk 1. Let's add the task to this product. <pre><code>curl --location --request PUT 'http://localhost:5001/product_task_association' \\\n--header 'Authorization: backoffice_secret' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n \"datetime\": \"'\"$(date -u +\"%Y-%m-%dT%H:%M:%S.%3NZ\")\"'\",\n \"product_pk\": 1,\n \"task_pk\": &lt;task_pk retrieved from previous command&gt;\n}'\n</code></pre></p> <p>STEP 4: Test your task</p> <p>Run your local Mojodex instance and access the web or mobile app.</p> <p>You should now see your task in the list of available tasks. If you don't, ensure to reload the app to get rid of any potential cache.</p>"},{"location":"guides/users/new_user/","title":"Create a new user","text":"<p>There are 2 ways for new users to be created: - Autonomous signup: The user creates an account on the platform using \"Sign up\" button. - Admin creation: An admin creates an account for the user using administration route.</p>"},{"location":"guides/users/new_user/#autonomous-signup","title":"Autonomous signup","text":"<p>When a user clicks the \"sign up\" button on Mojodex homepage, they are redirected to the sign up page. The user is asked to fill in the following information: - name - email - password</p> <p>Once the user has filled in the information, they click the \"sign up\" button and they are redirected to an onboarding process.</p> <ol> <li> <p>They have to accept the terms and conditions if provided, else accept to be respectful when adressing the assistant. </p> </li> <li> <p>They have to choose a profile category. This will determine their profile and so the tasks they can access. (See <code>docs/design-principles/profiles/whats_a_profile.md</code>) </p> </li> <li> <p>They can provide their company website for a more personalized experience. This step is optional. </p> </li> </ol> <p>Once they have completed the onboarding process, they are redirected to the dashboard. Their account is created and associated with a free product associated to the chosen category.</p>"},{"location":"guides/users/new_user/#admin-creation","title":"Admin creation","text":"<p>An admin can create a new user account by using dedicated administration routes. Here is the process:</p> <ol> <li> <p>Create user account: You can get helped by using the dedicated route so that GPT-4 generates a first json for you from your requirements. <pre><code>curl --location --request PUT 'http://localhost:5001/user' \\\n--header 'Authorization: backoffice_secret' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\"datetime\": \"2024-02-14T17:49:26.545180\",\n\"name\": \"user_name\",\n\"email\": \"user@email.com\",\n\"password\": \"user_temporary_password\",\n\"language_code\": \"en\",\n\"skip_user_validation\": true\n}'\n</code></pre></p> </li> <li> <p>Affect a role to the user: <pre><code>curl --location --request PUT 'http://localhost:5001/role' \\\n--header 'Authorization: backoffice_secret' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\"datetime\": \"2024-02-14T17:49:26.545180\",\n\"profile_pk\": 1,\n\"user_email\": \"user_email@email.com\"\n}'\n</code></pre></p> </li> </ol> <p>Once this is done, the user can log in with the temporary password and will directly access the dashboard. They can change their password using the \"forget password\" link on the login page.</p> <p>Note that this feature is available only if an email service has been set in configuration.</p>"},{"location":"guides/workflows/new_workflow/","title":"Create a new workflow","text":""},{"location":"guides/workflows/new_workflow/#technical-definition","title":"Technical definition","text":"<p>A workflow is a sequence of steps that the agent must execute one by one. A step is code: anything can be done in this code including complex actions as API calls.</p> <p>The result of each step execution is always available to the user that can consult it. On the steps requiring user validation, user can edit the step result and sometimes open a chat to give an instruction to relaunch the step. Compared to the instruct tasks, the workflows are more complex and constrainted, allowing the user to keep more control over the agent's actions.</p>"},{"location":"guides/workflows/new_workflow/#how-to-create-a-new-workflow","title":"How to create a new workflow?","text":""},{"location":"guides/workflows/new_workflow/#step-1-create-the-steps-code","title":"STEP 1: Create the steps' code","text":"<p>In <code>mojodex_core&gt;workflows</code> create a new folder named by your workflow. In this folder, create one file per step in your workflow. In each of those files, implement the corresponding step code. A workflow step is a class that implements the <code>WorkflowStep</code> class. </p> <p>An implementation of <code>WorkflowStep</code> overrides the method <code>_execute()</code>. It looks like this:</p> <pre><code>from mojodex_core.entities.workflow_step import WorkflowStep      \n\nclass MyWorkflowStep(WorkflowStep):\n\n\n    def _execute(self, parameter: dict, learned_instructions: dict, initial_parameter: dict, past_validated_steps_results: List[dict], user_id: str, user_task_execution_pk: int, task_name_for_system: str, session_id:str):\n        try: \n            return [{'output_key1': &lt;output&gt;, 'output_key2': &lt;output&gt;}]\n        except Exception as e:\n            raise Exception(f\"execute :: {e}\")\n</code></pre> <p>The result of the step execution must be a list of dictionaries. The next step of the workflow will be executed as many time as there are dictionaries in the list, each time with the corresponding dictionary as parameter.</p>"},{"location":"guides/workflows/new_workflow/#step-2-add-your-steps-to-the-steps-library","title":"STEP 2: Add your steps to the steps library","text":"<p>In <code>mojodex_core&gt;workflows&gt;steps_library.py</code>, add your steps to the <code>STEPS</code> dictionary. The key must be the name of the step as later defined in DB and the value must be the class of the step. This is used to dynamically load the steps from their name in the database.</p>"},{"location":"guides/workflows/new_workflow/#step-3-create-the-workflow","title":"STEP 3: Create the workflow","text":"<p>To create a new workflow, you can use the dedicated route PUT <code>/task</code>.</p> <p>Replace <code>&lt;BACKOFFICE_SECRET&gt;</code> with your actual token and name, steps, icon and description with the actual workflow name, steps, icon and description.</p> <p>Careful: steps names must match the ones in the steps library.</p> <p>Then, run the following command in your terminal:</p> <pre><code>curl --location --request PUT 'http://localhost:5001/task' \\\n--header 'Authorization: &lt;BACKOFFICE_SECRET&gt;' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\"datetime\": \"2024-02-14T17:49:26.545180\",\n    \"task_type\": \"workflow\",\n    \"predefined_actions\": [],\n    \"name_for_system\": \"&lt;WORKFLOW_NAME_FOR_SYSTEM&gt;\",\n    \"icon\": \"&lt;EMOJI&gt;\",\n    \"definition_for_system\": \"&lt;WORKFLOW_DEFINITION_FOR_SYSTEM&gt;\",\n    \"output_type\": \"document\",\n    \"platforms\": [\"webapp\"], # List of platforms where the workflow is available. Workflows are not yet implemented on mobile app.\n    \"steps\": [{\n        \"name_for_system\": \"&lt;STEP_NAME_FOR_SYSTEM&gt;\",\n        \"definition_for_system\":  \"&lt;STEP_DEFINITION_FOR_SYSTEM&gt;\",\n        \"rank\": 1,\n        \"review_chat_enabled\": false, # Whether the chat is enabled at the end of the step or not.\n        \"user_validation_required\": true, # Whether the user validation is required or not at the end of this step\n        \"step_displayed_data\":[\n            {\n                \"language_code\": \"&lt;2-LETTERS LANGUAGE-CODE&gt;\",\n                \"name_for_user\": \"&lt;STEP_NAME_FOR_USER&gt;\",\n                \"definition_for_user\": \"&lt;STEP_DEFINITION_FOR_USER&gt;\"\n            },\n            ...\n        ]},\n        ...\n        ],\n    \"task_displayed_data\": [\n        {   \n            \"language_code\":\"&lt;2-LETTERS LANGUAGE-CODE&gt;\",\n            \"name_for_user\": &lt;WORKFLOW_NAME_FOR_USER&gt;\",\n            \"definition_for_user\": &lt;WORKFLOW_DEFINITION_FOR_USER&gt;\",\n            \"json_input\": [\n                {\"input_name\": \"&lt;INPUT_NAME&gt;\", \n                \"description_for_user\": \"&lt;DESCRIPTION_FOR_USER&gt;\",\n                    \"description_for_system\": \"&lt;DESCRIPTION_FOR_SYSTEM&gt;\",\n                \"type\": \"text_area\"},\n                ...\n               ]\n        },\n         ...\n    ],\n    \"result_chat_enabled\": false # Whether the chat is enabled at the end of the workflow on the produced text or not.\n}'\n</code></pre> <p>Note regarding \"result_chat_enabled\" parameter: Be careful that once on result page:  - Assistant will no longer be able to re-launch past steps code - therefore relaunch api requests or other\u2026  - Text has been generated by a whole chain of steps. It could be too long for context-windows on a basic LLM chat call.</p> <p>As a consequence, depending on the workflow, it may be relevant to disable the chat on result to avoid user confusion (preventing them to ask to re-launch a query for example)</p>"},{"location":"guides/workflows/new_workflow/#step-4-associate-workflow-to-a-user-through-a-product","title":"STEP 4: Associate workflow to a user through a product.","text":"<p>Replace <code>&lt;BACKOFFICE_SECRET&gt;</code> with your actual token and <code>&lt;user_id&gt;</code> and <code>&lt;task_pk&gt;</code> with the actual user id and workflow primary key. Then, run the following command in your terminal:</p> <p>Default user <code>demo@example.com</code> is associated with default product <code>demo</code> with pk 1. Let's add the task to this product. <pre><code>curl --location --request PUT 'http://localhost:5001/product_task_association' \\\n--header 'Authorization: backoffice_secret' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n \"datetime\": \"'\"$(date -u +\"%Y-%m-%dT%H:%M:%S.%3NZ\")\"'\",\n \"product_pk\": 1,\n \"task_pk\": &lt;task_pk retrieved from previous command&gt;\n}'\n</code></pre></p>"},{"location":"technical-architecture/backend/","title":"Backend","text":"<p>The Mojodex Backend, inspired by System 1 from cognitive science, is responsible for managing the data and implementing the business logic of the digital assistant.</p>"},{"location":"technical-architecture/backend/#functionalities","title":"Functionalities","text":""},{"location":"technical-architecture/backend/#rest-api-for-business-logic","title":"REST API for Business Logic","text":"<p>Implemented with Flask, the REST API handles data management and business logic, providing fast and tailored responses to users.</p> <p><code>backend/app/app.py</code> <pre><code>[...]\nfrom flask import Flask\nfrom flask_restful import Api\n\napp = Flask(__name__)\napi = Api(app)\n\nfrom http_routes import *\nHttpRouteManager(api)\n[...]\n</code></pre></p> <p>The API routes are all defined in <code>backend/app/http_routes.py</code> in the <code>HttpRouteManager</code> class, pointing to related Flask Resources in <code>backend/app/routes/</code>.</p> <p>Here's the link to the Backend API documentation - Swagger file.</p>"},{"location":"technical-architecture/backend/#database-access","title":"Database Access","text":"<p>The Backend uses SQLAlchemy to interact with the PostgreSQL database, ensuring efficient data management and storage. It can both read and write from the database.</p> <p><code>backend/app/app.py</code> <pre><code>[...]\nfrom flask_sqlalchemy import SQLAlchemy\n\napp = Flask(__name__)\n\napp.config[\n    \"SQLALCHEMY_DATABASE_URI\"] = f\"postgresql+psycopg2://{os.environ['DBUSER']}:{os.environ['DBPASS']}@{os.environ['DBHOST']}:5432/{os.environ['DBNAME']}\"\n\ndb = SQLAlchemy(app)\n[...]\n</code></pre></p> <p>The database models generated with SQLAcodegen can be found in <code>mojodex_core/entities/db_base_entities.py</code>. Those are used by the Backend to interact with the database though sqlalchemy.</p> <p>Important Note: Flask-Sqlalchemy manages sessions and closes sessions on its own when a request is done. It is not necessary to manage sessions manually. However, when accessing the database in a thread that is not the main one, it does not close sessions automatically, creating locks in the database. Therefore, when requiring to access the database out of a request context, use <code>@with_db_session</code> defined in <code>mojodex_core/db.py</code> to access, open and close a session specifically where it is needed.</p>"},{"location":"technical-architecture/backend/#real-time-interaction-management","title":"Real-Time Interaction Management","text":"<p>Using SocketIO through <code>flask_socketio</code>, the Backend enables interactive sessions between the assistant and the user, ensuring instant feedback and dynamic conversation flow.</p> <p><code>backend/app/app.py</code> <pre><code>[...]\nfrom flask_socketio import SocketIO\n\nserver_socket = SocketIO(app, ping_timeout=40, ping_interval=15, logger=False, engineio_logger=False, cors_allowed_origins=\"*\", )\n[...]\n</code></pre></p> <p>Note that the socketio server is now only used to emit messages. Reception of user messages are done through the REST API for reliability.</p>"},{"location":"technical-architecture/backend/#emission-of-assistant-messages","title":"Emission of Assistant Messages","text":"<p>To separate messages from one user to another, we use Socketio's \"room\" principle along with Mojodex's Session management. </p> <p>A Mojodex's Session represents an interaction between the user and the assistant. It contains the list of messages exchanged during this interaction and is identified by a unique session_id.</p> <p>The user can resume a Session at any moment, for example when re-opening a task from their history.</p> <p>The Session's unique session_id is used to identify Socketio's room for the user and the assistant to exchange messages. In the emission code, this corresponds to the <code>to</code> parameter of the <code>server_socket.emit()</code> method.</p> <ul> <li> <p>Assistant partial messages, containing tokens as streamed by the LLM, are sent as soon as received through socketio dedicated events (<code>mojo_token</code> and <code>draft_token</code>). This allow to stream the assistant's response in real-time to the user so that the user can see the assistant's response being built. <code>backend/app/models/assistant/session_controller.py</code> <pre><code>[...]\n@token_stream_callback('mojo_token')\n    def _mojo_message_stream_callback(self, partial_text):\n        try:\n            return {\"text\": partial_text, 'session_id': self.session.session_id}\n        except Exception as e:\n            raise Exception(f\"_mojo_message_stream_callback :: {e}\")\n[...]\n</code></pre></p> </li> <li> <p>Assistant messages, whether there are simple messages or containing task's result (produced_text) are sent through socketio using <code>backend/app/socketio_message_sender.py</code> along with a callback. The callback must be called by the frontend to confirm the message has been received (acknowledged), if not, the assistant will send the message again every 5 seconds for 10minutes or until the message is acknowledged. <pre><code>[...]\ndef send_mojo_message_with_ack(self, message, session_id, event_name='mojo_message', remaining_tries=120):\n        [...]\n        server_socket.emit(event_name, message, to=session_id, callback=self._mojo_message_received)\n\n        def waiting_for_acknowledgment():\n            [...]\n\n        # start a timer of 5 seconds, in 5 seconds if it has not been killed, it will resend the message. Use executor to run async\n        if remaining_tries &gt; 0:\n            executor.submit(waiting_for_acknowledgment)\n</code></pre> </p> </li> </ul>"},{"location":"technical-architecture/backend/#system-1system-2-abstraction","title":"System 1/System 2 Abstraction","text":"<p>To draw a parallel with the System 1/System 2 abstraction, Mojodex's Backend functions as the digital counterpart to System 1 thinking.</p> <p>It swiftly processes incoming data and orchestrates real-time interactions similar to our intuitive cognitive processes. Operating seamlessly like System 1, the Backend ensures instantaneous feedback and dynamic conversation flows, akin to rapid, non-conscious decision-making.</p>"},{"location":"technical-architecture/background/","title":"MOJODEX Background","text":"<p>The background is responsible for processing data in the background. It is useful for long-running process that would otherwise block the main backend. It is also useful for processing batch data (like sending emails or notifs to a group of users).</p>"},{"location":"technical-architecture/background/#structure","title":"Structure","text":"<p>The background is a Flask application which routes can only be called by Mojodex's backend or by the Scheduler.</p> <p>The background must be deployed in the same network as the backend and scheduler so that the backend can call its routes but its routes must not be accessible from the outside.</p> <p><code>background/app/app.py</code> <pre><code>[...]\nfrom flask import Flask\nfrom flask_restful import Api\n\napp = Flask(__name__)\napi = Api(app)\n\nfrom http_routes import *\nHttpRouteManager(api)\n[...]\n</code></pre></p> <p>The API routes are all defined in <code>background/app/http_routes.py</code> in the <code>HttpRouteManager</code> class, pointing to related Flask Resources in <code>background/app/routes/</code>.</p>"},{"location":"technical-architecture/background/#usage","title":"Usage","text":"<p>When Mojodex's Backend or Scheduler calls Mojodex's Background to manage a process, it sends a request using REST API. Then, the route uses the app <code>ThreadPoolExecutor executor</code> to launch the required process in a parallel thread and return a 200 status code to indicate that the process has been launched.</p> <p>Access to the database within parallel threads is done by decorating methods requiring this access with decorator <code>@with_db_session</code>. This decorator opens a new Session accessing the database, executes the decorated method and closes the session. This ensures no database session will remain open after the method is executed.</p> <p>Here is an example of a parallel process to extract To-Do items from a task:</p> <p><code>background/app/models/todos/todos_creator.py</code> <pre><code>class TodosCreator:\n\n    # The instanciation is done by passing a key and not a DB object to avoid keeping a DB session open while a parallel thread using this object will be launched\n    def __init__(self, user_task_execution_pk):\n        self.user_task_execution_pk = user_task_execution_pk\n\n    # This is the method launched in a parallel thread\n    def extract_and_save(self):\n        collected_data = self._collect_data()\n        json_todos = self._extract(*collected_data)\n        [...]\n        self._save_to_db(todo['todo_definition'], todo['due_date'])\n\n    @with_db_session\n    def _collect_data(self, db_session):\n        # This method uses a dedicated db_session to access the database and retrieve all the data needed for the process\n        # It does not return any DB object but only required data to avoid keeping the DB session open\n        [...]\n        user = db_session.query(User) ...\n        [...]\n        return user.user_id, user.datetime_context, user.name, ...\n\n    def _extract(self, user_id, datetime_context, name, ...):\n        # This method processes the raw data provided by _collect_data to extract To-Do items\n        [...]\n\n    @with_db_session\n    def _save_to_db(self, description, due_date, db_session):\n         # create new todo\n            new_todo = MdTodo(\n                creation_date=datetime.now(),\n                description=description,\n                user_task_execution_fk=self.user_task_execution_pk\n            )\n            db_session.add(new_todo)\n            [...]\n            db_session.commit()\n            [...]\n</code></pre></p> <p>This process is launched when calling route <code>background/app/routes/extract_todos.py</code> from the Backend: <pre><code>class ExtractTodos(Resource):\n\n    def post(self):\n        [...]\n        todos_creator = TodosCreator(user_task_execution_pk)\n        executor.submit(todos_creator.extract_and_save)\n        return {\"success\": \"Process started\"}, 200\n</code></pre></p>"},{"location":"technical-architecture/background/#functionalities","title":"Functionalities","text":"<p>For now, Mojodex's Background manages 5 processes:</p>"},{"location":"technical-architecture/background/#extracttodos","title":"ExtractTodos","text":"<ul> <li>Route: <code>background/app/routes/extract_todos.py</code></li> <li>Service: <code>background/app/models/todos/todos_creator.py</code></li> </ul> <p>This process is launched at the end of a task to extract any next step the user could have mentioned explicitely in the task process and turn those into To-Do items to add to the user's To-Do list. It is triggered by the Scheduler, calling the Backend that collects ended tasks that have not been processed yet and calls the Background to launch the extraction process for each of those tasks.</p>"},{"location":"technical-architecture/background/#rescheduletodo","title":"RescheduleTodo","text":"<ul> <li>Route: <code>background/app/routes/reschedule_todo.py</code></li> <li>Service: <code>background/app/models/todos/todos_rescheduler.py</code></li> </ul> <p>This process is called to reschedule a To-Do item that passed its due date without being deleted or marked as completed. It is triggered by the Scheduler, calling the Backend that collects To-Do items that have passed their due date and calls the Background to launch the rescheduling process for each of those To-Do items.</p>"},{"location":"technical-architecture/background/#createdocumentfromwebsite","title":"CreateDocumentFromWebsite","text":"<ul> <li>Resource: <code>background/app/routes/create_document_from_website.py</code></li> <li>Service: Uses <code>mojodex_core.website_parser</code> to parse the website, extract its content and turn it into a document.</li> </ul> <p>This process is called to parse a website, extract its content, cut it into chunks, vectorized and load it in database as a document. It is used when user provides a new website as resource. It is useful to launch it in background because the process of validating chunks that are relevant and embedding them can be long.</p>"},{"location":"technical-architecture/background/#updatedocument","title":"UpdateDocument","text":"<ul> <li>Resource: <code>background/app/routes/update_document.py</code></li> <li>Service: Uses <code>mojodex_core.website_parser</code> if the document is a website, <code>Document.update</code> otherwise.</li> </ul> <p>This process is called to update a document in the database when user provides a new version of a resource. If the document is a website, it will parse the website again, extract its content, cut it into chunks, vectorized and update associated document in database. If the document is not a website but directly a text, it will only update the document in database. Anyway, the process of updating a document requires embedding the new version, which take time and therefore is launched through the Background.</p>"},{"location":"technical-architecture/background/#eventsgeneration","title":"EventsGeneration","text":"<ul> <li>Resource: <code>background/app/routes/event_generation.py</code></li> <li>Cortex: <code>background/app/models/events/event_generator.py</code> (abstract class, implementation depends on parameters of request)</li> </ul> <p>This process is called any time the Backend wants to send a notification to the user whether it is a mail, push notification... The Background is responsible for notification content generation and event sending. For now, 1 type of events are generated: - todo_daily_emails: An email to remind the user of his To-Do items for the day. Launched from the Scheduler every day at 8am, the Backend selects the user that opted-in this option and triggers the Background to generate the email content.</p>"},{"location":"technical-architecture/background/#system-1system-2-abstraction","title":"System 1/System 2 Abstraction","text":"<p>To draw a parallel with the System 1/System 2 abstraction, Mojodex's Background embodies the deliberate nature of System 2 thinking.</p> <p>It meticulously manages long-running processes and handles batch data tasks with careful attention, akin to System 2's deliberate memory search and complex computations. This component ensures the smooth functioning of Mojodex's operations, providing the necessary depth and thoroughness to complement the swift responsiveness of the Backend.</p>"},{"location":"technical-architecture/database/","title":"Database","text":"<p>The Mojodex database is a PostgreSQL database using the pg_vector extension to store and query vector data.</p> <p>The database is launched as a Docker container and is accessed by the <code>backend</code> and <code>background</code> services. See general documentation for more information.</p>"},{"location":"technical-architecture/database/#database-schema","title":"Database schema","text":"<p>You can have a look at the database schema at dbdiagram.io: https://dbdiagram.io/d/MojodexDatabase-659d0645ac844320ae85b440</p> <p>Table names are prefixed with <code>md_</code> standing for \"Mojodex\".</p>"},{"location":"technical-architecture/database/#initialization-of-mojodex-data","title":"Initialization of Mojodex data","text":"<p>The <code>create-mojodex-data.sql</code> and <code>init-mojodex-data.sql</code> files respectively contains the SQL script to create the Mojodex schema and data. You can modify this file to add or remove data. For now, all updates are stacked in this file and no sql patch is provided.</p>"},{"location":"technical-architecture/database/#entities","title":"Entities","text":"<p>Each table is represented as a python class in <code>mojodex_code/entities/db_base_entities.py</code>. This file is generated using <code>sqlacodegen</code>tool: <pre><code>sqlacodegen postgresql+psycopg2://$DBUSER:$DBPASS@localhost:5432/$DBNAME --outfile mojodex_core/entities/db_base_entities.py\n</code></pre></p> <p>\u26a0\ufe0f  Be sure to install <code>sqlacodegen</code> with the appropriate pg_vector features: <pre><code>python3 -m pip install git+https://github.com/hoomano/sqlacodegen.git@feature-pgvector\n</code></pre></p> <p>Some of those entities are then extended in <code>mojodex_code/entities/</code> to add specific methods or attributes. To get the most out of an entity in the code, retrieve it by querying then database using the aproppriate daughter class.</p> <p>Example using <code>User</code> entity, daughter of base entity <code>MdUser</code>: <pre><code>db_session.query(User).get(user_id)\n</code></pre></p> <p>You can also directly create object using the daughter class: <pre><code>new_user = User(name=\"John Doe\", email=\"john@doe.com\")\ndb_session.add(new_user)\ndb_session.commit()\n</code></pre></p>"},{"location":"technical-architecture/overview/","title":"Global Architecture","text":""},{"location":"technical-architecture/overview/#principles","title":"Principles","text":"<p>Mojodex Architecture is built upon the foundational principles of System 1/System 2 abstraction, a concept derived from cognitive psychology.</p> <ul> <li>System 1 represents fast, intuitive, and unconscious thinking.</li> <li>System 2 embodies slower, deliberate, and analytical thought processes. </li> </ul> <p>By integrating these cognitive frameworks into its design, Mojodex aims to create a digital assistant system that combines the rapid responsiveness of System 1 with the careful decision-making of System 2. </p> <p>This documentation provides an overview of Mojodex's architecture, exploring how these cognitive principles inform its structure and functionality.</p> <p>Learn more about the System 1/System 2 abstraction</p>"},{"location":"technical-architecture/overview/#architecture-overview","title":"Architecture Overview","text":""},{"location":"technical-architecture/overview/#components","title":"Components","text":"Component Role Documentation Link Backend Communication hub for real-time dialogue and management of application business logic. Mojodex's Backend serves as the digital counterpart to System 1 thinking. Backend Documentation Background Handles intensive tasks behind-the-scenes. Useful for Long-Running Processes and Batch Data Processing. Mojodex's Background embodies the deliberate nature of System 2 thinking. Background Documentation Scheduler Executes code at specific times/intervals. Mojodex's Scheduler embodies a proactive aspect akin to System 2 thinking Scheduler Documentation Database Stores and manages data Database Documentation Mobile App Interface for mobile devices Mobile App Documentation Web App Interface for web browsers Web App Documentation Next Proxy Manages and authenticates requests from the webapp interface to the backend. Next Proxy Documentation"},{"location":"technical-architecture/scheduler/","title":"Scheduler","text":"<p>The scheduler is responsible for running tasks at specific times or intervals. It is useful for running tasks that are not directly related to a user's request, like sending emails or notifs to a group of users. It is also useful for proactivity, to let Mojo work on something by checking state of a user or a task at a certain frequency and act accordingly.</p>"},{"location":"technical-architecture/scheduler/#functionalities","title":"Functionalities","text":"<p>Mojodex's Scheduler has 2 main directory containing:</p> <ul> <li>Scheduled tasks <code>scheduler/app/scheduled_tasks</code></li> <li>Time based tasks <code>scheduler/app/time_based_tasks</code></li> </ul> <p>Those tasks are run thanks to the <code>scheduler/app/main.py</code> file that keeps the scheduler running and checks for tasks to run using the <code>schedule</code> library.</p> <pre><code>while True:\n    schedule.run_pending()\n    time.sleep(1)\n</code></pre>"},{"location":"technical-architecture/scheduler/#scheduled-tasks","title":"Scheduled tasks","text":"<p>Scheduled tasks contains code that are run at a specific frequency.  <pre><code>### Abstract class named ScheduledTask that has a method job() and a constructor that runs  schedule.every(X).seconds.do(job), X being the number of seconds between executions (param)\nfrom abc import ABC, abstractmethod\nimport schedule\n\nclass ScheduledTask(ABC):\n\n    def __init__(self, n_seconds):\n        schedule.every(n_seconds).seconds.do(self.job)\n\n    @abstractmethod\n    def job(self):\n        \"\"\"Method that will be executed every n_seconds seconds\"\"\"\n        pass\n</code></pre></p> <p>As Mojodex's Scheduler does not have database access, Scheduled tasks jobs are Backend or Background API calls. Performed at a regular interval, they are useful for checking the state of a user or a task and act accordingly.</p> <p>The Scheduled tasks are implemented in the <code>scheduler/app/main.py</code> file.</p> <pre><code>[...]\n# Scheduled tasks\nPurchasesExpirationChecker(3600) # check ended free_plan every 1 hour\nExtractTodos(600) # extract todos every 10 minutes\nRescheduleTodos(3600) # reschedule todos every 1 hour\nif push_notifications:\n    SendDailyNotifications(3600) # send daily notifications every 1 hour (filtered by timezone)\nif emails:\n    #SendDailyEmails(3600) # send daily emails every 1 hour (filtered by timezone)\n    SendTodoDailyEmails(3600) # send todo daily emails every 1 hour (filtered by timezone)\n    CheckDisengagedFreeTrialUsers(86400)  # check disengaged free trial users every day\nFirstHomeChatOfWeek(3600)\n[...]\n</code></pre>"},{"location":"technical-architecture/scheduler/#time-based-tasks","title":"Time based tasks","text":"<p>Time based tasks contains code that are run at a specific time of the day.  <pre><code>from abc import ABC, abstractmethod\nimport schedule\n\n\nclass TimeBasedTask(ABC):\n\n    def __init__(self, hour=10, minute=0, second=0, weekday=None,):\n        if weekday is not None:\n            schedule.every().monday.at(f\"{hour}:{minute}:{second}\").do(self.job) if weekday == 0 else None\n            schedule.every().tuesday.at(f\"{hour}:{minute}:{second}\").do(self.job) if weekday == 1 else None\n            schedule.every().wednesday.at(f\"{hour}:{minute}:{second}\").do(self.job) if weekday == 2 else None\n            schedule.every().thursday.at(f\"{hour}:{minute}:{second}\").do(self.job) if weekday == 3 else None\n            schedule.every().friday.at(f\"{hour}:{minute}:{second}\").do(self.job) if weekday == 4 else None\n            schedule.every().saturday.at(f\"{hour}:{minute}:{second}\").do(self.job) if weekday == 5 else None\n            schedule.every().sunday.at(f\"{hour}:{minute}:{second}\").do(self.job) if weekday == 6 else None\n        else:\n            schedule.every().day.at(f\"{hour}:{minute}:{second}\").do(self.job)\n\n\n    @abstractmethod\n    def job(self):\n        \"\"\"Method that will be executed at the specified time\"\"\"\n        pass\n</code></pre></p> <p>For now, Mojodex Scheduler doesn't have any time based tasks. Indeed, when running code for a user at a specific time, it is often more relevant to adapt to the user's timezone (for example, to process To-Do rescheduling while user is sleeping).  Therefore, a Scheduled task is more appropriate to trigger a backend call every hour and filter the concerned users by timezone.</p>"},{"location":"technical-architecture/scheduler/#system-1system-2-abstraction","title":"System 1/System 2 Abstraction","text":"<p>In alignment with the System 1/System 2 framework, Mojodex's Scheduler embodies a proactive aspect akin to System 2 thinking.</p> <p>It functions as the deliberate planner within Mojodex, orchestrating scheduled code execution and empowering the assistant to take preemptive actions based on predefined criteria. Just as System 2 engages in deliberate planning and decision-making, the Scheduler ensures the efficient and effective operation of Mojodex by executing tasks at specific times or intervals, optimizing the assistant's performance in a systematic and thoughtful manner.</p>"},{"location":"technical-architecture/webapp/","title":"Web App","text":"<p>The Mojodex web app is a web application that allows you to interact with the Mojodex API.</p>"},{"location":"technical-architecture/webapp/#structure","title":"Structure","text":"<p>The web app is composed of: - A frontend written in React.js - A backend proxy written in Node.js</p> <p>The frontend is served by the backend proxy, which also serves as a reverse proxy to the Mojodex API for REST requests.</p> <p>IMPORTANT NOTE: For now, Socketio requests are not proxied by the backend. This means that the frontend must connect directly to the Mojodex API for socketio requests.</p>"},{"location":"technical-architecture/general-doc/","title":"Mojodex Technical Documentation","text":"<p>What's this doc for?  High level understanding of the architecture of Mojodex and the relationship between its components. More detailed documentation is available in each components directory.</p> <p>Mojodex is an open source tool, a platform for creating digital assistants. Designed around tasks, Mojodex enables developers and IT teams to create customised digital assistants for their staff in a simple way. The platform can be deployed in the cloud and works with both backend and frontend tools. Administrators can configure tasks for users, and there are several types of tasks and interfaces for using them. Mojodex allows companies to take ownership of the development of their AI tools.</p>"},{"location":"technical-architecture/general-doc/#1-mojodex-technical-architecture","title":"1. Mojodex technical architecture","text":""},{"location":"technical-architecture/general-doc/#main-components","title":"Main components","text":"<ul> <li>Mobile application: Developed in Flutter, it accesses the Python backend directly.</li> <li>Web application : Developed in React, it accesses the Python backend via a Next.js proxy.</li> <li>CLI: Command-line tool for developers.</li> <li>Backend : Manages real-time interactions and REST APIs.</li> <li>Background: Manages long and proactive tasks.</li> <li>Scheduler: triggers tasks at given times.</li> <li>PostgreSQL database with PGVector: Stores data and embeddings.</li> </ul>"},{"location":"technical-architecture/general-doc/#communication-flows","title":"Communication flows","text":"<ul> <li>REST routes: Used for HTTP communications, shown in red.</li> <li>Socket.io streams: Used for real-time communications, shown in green.</li> </ul>"},{"location":"technical-architecture/general-doc/#2-backend-component","title":"2. Backend component","text":"<p>The backend is a Python application implemented with Flask to manage REST APIs and business logic. It uses SQLAlchemy to access the database and Flask-SocketIO for real-time interactions.</p>"},{"location":"technical-architecture/general-doc/#routes-and-session-management","title":"Routes and session management","text":"<p>Routes are defined in a <code>HTTPRouteManager</code> class. The backend uses a <code>db</code> object provided by Flask-SQLAlchemy for interactions with the database. A <code>@with_db_session</code> decorator is used to handle database sessions outside of route calls, to avoid database locks. Models are defined in <code>mojodex_core/entities/db_base_entities.py</code></p>"},{"location":"technical-architecture/general-doc/#real-time-interactions","title":"Real-time interactions","text":"<p>The backend uses Flask-SocketIO to manage real-time interactions, in particular for chat between the user and the assistant. Messages are sent via Socket.io rooms, separated by session ID. Authentication of Socket.io flows is managed in the same way as Flask authentication, using tokens.</p>"},{"location":"technical-architecture/general-doc/#message-management","title":"Message management","text":"<p>Messages between the backend and the frontend are managed via Socket.io. Important messages, such as Mojo messages and draft messages, use acknowledgement mechanisms to ensure that they are received by the client.</p>"},{"location":"technical-architecture/general-doc/#3-background-component","title":"3. Background component","text":"<p>The background is designed to manage long and proactive processes. It uses Flask to expose HTTP routes and a thread pool executor to launch processes in parallel. Processes are logged at admin level, and the background handles errors autonomously.</p>"},{"location":"technical-architecture/general-doc/#features","title":"Features","text":"<p>Features implemented in the background include: - Extracting and rescheduling to-dos. - Creating and updating documents from a website. - Event generation for push notifications and emails.</p>"},{"location":"technical-architecture/general-doc/#database-access","title":"Database access","text":"<p>The background has access to the database via SQLAlchemy and also uses the <code>@with_db_session</code> decorator to manage database sessions outside of route calls.</p>"},{"location":"technical-architecture/general-doc/#thread-management","title":"Thread management","text":"<p>The background runs processes in separate threads to avoid blocking the main Flask server. Process results are logged, and the background handles errors autonomously.</p>"},{"location":"technical-architecture/general-doc/#4-postgresql-database-and-pgvector","title":"4. PostgreSQL database and PGVector","text":""},{"location":"technical-architecture/general-doc/#choice-of-postgresql","title":"Choice of PostgreSQL","text":"<p>PostgreSQL was chosen for its flexibility and its ability to manage vector columns via the PGVector extension. Tests were carried out with other vector databases, but PostgreSQL proved sufficient for the needs of Mojodex.</p>"},{"location":"technical-architecture/general-doc/#database-schema","title":"Database schema","text":"<p>The database schema is available on DB Diagram. Table names are prefixed with <code>md_</code> for Mojodex. A <code>create-mojodex-data.sql</code> script creates the database schema, and an <code>init-mojodex-data.sql</code> script initializes the data.</p> <p>See section #23 for a high level overview of the database structure and organisation</p> <p>Also see detailed database documentation here: https://dbdiagram.io/d/MojodexDatabase-659d0645ac844320ae85b440</p>"},{"location":"technical-architecture/general-doc/#representing-entities","title":"Representing entities","text":"<p>Database entities are represented in Python classes generated by SQLacodegen. These classes can be overloaded to add specific attributes.</p>"},{"location":"technical-architecture/general-doc/#using-json","title":"Using JSON","text":"<p>Some columns in the database use the JSON type to retain flexibility on certain fields, such as the <code>message</code> field in the <code>md_message</code> table.</p>"},{"location":"technical-architecture/general-doc/#5-scheduler","title":"5. Scheduler","text":"<p>The Mojodex scheduler is designed to trigger actions at specific intervals. Currently, there is no implementation for triggering actions at a specific time of day. Actions are triggered according to the interval and the user's timezone.</p>"},{"location":"technical-architecture/general-doc/#how-the-scheduler-works","title":"How the scheduler works","text":"<p>The scheduler uses the Python <code>schedule</code> module to execute tasks at a specific frequency. These tasks are implemented in the scheduler main, which usually runs in a simple Python container. The scheduler can call either the backend for administrative tasks (such as updating users whose purchases have expired), or the background for proactive actions (such as sending notifications or retrieving tasks).</p>"},{"location":"technical-architecture/general-doc/#6-webapp","title":"6. Webapp","text":"<p>The web app gives users access to the Mojodex API. The front-end is developed in React and the proxy in Node.js. REST Flows pass through the proxy, while Socket.IO flows pass directly between the web app and the Python backend.</p>"},{"location":"technical-architecture/general-doc/#user-authentication","title":"User authentication","text":"<p>Users can be authenticated via login/password or via providers (Google, Apple...). The authentication request arrives on the Next server (Node.js), is rerouted to the Python backend for verification, and the authentication token is sent back to the client on the front end for future calls.</p>"},{"location":"technical-architecture/general-doc/#7-deployment-management","title":"7. Deployment management","text":""},{"location":"technical-architecture/general-doc/#71-local-deployment","title":"7.1 Local deployment","text":"<p>To deploy Mojodex locally, there are 2 Docker Composes: a classic one and one for development (<code>docker-compose-dev.yml</code>). Each Docker Compose contains six Docker containers corresponding to different project directories, each with its own Dockerfile.</p> <ul> <li>mojodex-db</li> <li>mojodex-backend</li> <li>mojodex-background</li> <li>mojodex-scheduler</li> <li>mojodex-webapp</li> <li>(optionnal) mojodex-ollama</li> </ul>"},{"location":"technical-architecture/general-doc/#local-deployment-procedure","title":"Local deployment procedure","text":"<ol> <li>Clone the repo.</li> <li>Copy and modify the <code>.env</code> file from <code>.env.example</code>.</li> <li>Copy and modify the <code>.conf.example</code> files (models.conf, stt-models.conf, embeddings-models.conf).</li> <li>Start the services with <code>docker-compose up -d --build</code>.</li> <li>Access the web app on <code>localhost:3000</code> with the default user (email: demo@example.com, password: demo).</li> </ol>"},{"location":"technical-architecture/general-doc/#72-deployment-on-azure","title":"7.2 Deployment on Azure","text":"<p>Mojodex can be deployed on Azure using services such as Container Registry, App Services, Container Instances, Storage Account, and a Postgres database server in flexible mode.</p>"},{"location":"technical-architecture/general-doc/#deployment-procedure-on-azure","title":"Deployment procedure on Azure","text":"<ol> <li>Install Azure CLI and log in to Azure.</li> <li>Update the template configuration files (.conf).</li> <li>Use the <code>azure_deployment_script.sh</code> script to deploy services.</li> <li>Restart the Azure services after deployment.</li> <li>Access the web app via the URL provided by Azure.</li> </ol> <p>Caution: Note that this script is intended to be used more as a \u2018memory aid\u2019 than as a script to be run all at once without supervision.</p> <p>\ud83d\udca1 For Azure users, you can find advanced deployment informations in the following resources:</p> <ul> <li>Deployment Guide with Azure</li> </ul>"},{"location":"technical-architecture/general-doc/#8-data-management","title":"8. Data management","text":""},{"location":"technical-architecture/general-doc/#data-types","title":"Data types","text":"<ol> <li>Database: Contains all the business data required to run Mojodex.</li> <li>User files: Stored in the <code>/data</code> directory and organised by session.</li> <li>Datasets: Files created to use the data generated by Mojodex, in particular LLM calls.</li> <li>Cost files : Consumption logs to analyse the costs and usage of the various services.</li> </ol>"},{"location":"technical-architecture/general-doc/#data-details","title":"Data details","text":""},{"location":"technical-architecture/general-doc/#database","title":"Database","text":"<ul> <li>Stored locally in a Docker volume.</li> <li>In Azure mode, managed by the Azure Postgres server.</li> </ul>"},{"location":"technical-architecture/general-doc/#user-files","title":"User files","text":"<ul> <li>Stored in <code>/data/users/{user_id}/{session_id}</code>.</li> <li>Contain audio files, audio messages from the user, and uploaded images and videos.</li> </ul>"},{"location":"technical-architecture/general-doc/#datasets","title":"Datasets","text":"<ul> <li>Stored in <code>/data/prompt_datasets/{type}/{label}/{task_name}/{id}</code>.</li> <li>Contain LLM call parameters and generated responses.</li> </ul>"},{"location":"technical-architecture/general-doc/#cost-files","title":"Cost files","text":"<ul> <li>Stored as CSV files.</li> <li>Contain information on consumption by user, task and service.</li> </ul>"},{"location":"technical-architecture/general-doc/#9-differences-between-instruct-tasks-and-workflows","title":"9. Differences Between Instruct Tasks and Workflows","text":""},{"location":"technical-architecture/general-doc/#10-task-creation","title":"10. Task Creation","text":""},{"location":"technical-architecture/general-doc/#instruct-tasks","title":"Instruct Tasks","text":"<p>Instruct tasks are the simpler type of tasks in Mojodex. Here is the process to create an Instruct task:</p> <ol> <li>Identify Tasks: Identify the tasks that need to be created based on the job profiles within the company.</li> <li>Post-Task JSON Route: Use the <code>POST /task_json</code> route to generate a preliminary JSON definition of the task.<ul> <li>This route takes the task definition as a parameter and returns a JSON template.</li> <li>Ensure to review and adapt the JSON to fit your specific needs.</li> </ul> </li> <li>JSON Schema: The JSON format and the route are detailed in the OpenAPI documentation.</li> <li>Put-Task Route: Once the JSON is ready, send it via the <code>PUT /task</code> route to create the task in the database.</li> <li>SQL Script Alternative: Alternatively, you can write an SQL script to create tasks directly in the database, which can be useful for multi-environment deployments.</li> </ol>"},{"location":"technical-architecture/general-doc/#workflow-tasks","title":"Workflow Tasks","text":"<p>Workflow tasks involve a more complex process:</p> <ol> <li>Create Workflow Directory: In the <code>mojodex_core</code> module, under the <code>workflows</code> directory, create a new directory named after the workflow.</li> <li>Create Step Files: For each step in the workflow, create a Python file named after the step.<ul> <li>Each file should contain a class that extends <code>WorkflowStep</code> and overrides the <code>_execute</code> method.</li> <li>Ensure the input format of each step matches the output format of the previous step.</li> </ul> </li> <li>Step Library: Add each step to the <code>steps_library</code> file in the <code>mojodex_core/workflows</code> module, mapping step names to their corresponding classes.</li> <li>Workflow JSON: Create a JSON definition for the workflow task, similar to Instruct tasks but including the steps with their names, descriptions, and order.</li> <li>Put-Task Route: Send the workflow JSON via the <code>PUT /task</code> route.</li> </ol> <p>Creating a task does not make it available to users. It must be associated with a product through the <code>md_product_task_association</code> table. For more information on how to associate users to tasks, see section #2</p>"},{"location":"technical-architecture/general-doc/#11-task-execution-instruct","title":"11. Task Execution (<code>instruct</code>)","text":""},{"location":"technical-architecture/general-doc/#111-user-interaction","title":"11.1 User Interaction","text":"<p>When a user wants to execute a task, the following steps occur:</p> <ol> <li>Task Selection: The user clicks on \"New Task\" and sees a list of available tasks.</li> <li>Task Initiation:<ul> <li>Web App: A form appears with fields that the user must fill out to start the task. These fields are mandatory.</li> <li>Mobile App: The user sends an initial message, typically an audio message, containing all necessary inputs for the task.</li> </ul> </li> <li>Task Execution:<ul> <li>Web App: If all fields are filled correctly, the task starts immediately.</li> <li>Mobile App: The assistant may ask follow-up questions to gather any missing information before starting the task.</li> </ul> </li> </ol>"},{"location":"technical-architecture/general-doc/#112-technical-description","title":"11.2 Technical Description","text":""},{"location":"technical-architecture/general-doc/#step-1-task-initialization","title":"Step 1: Task Initialization","text":"<ul> <li>Route: <code>PUT /user_task_execution</code></li> <li>Action: Creates an instance of <code>UserTaskExecution</code> with a <code>JsonInput</code> field initialized with null values.</li> <li>Details:<ul> <li>A user is associated with multiple <code>UserTasks</code>.</li> <li>When a user starts a task, a new <code>UserTaskExecution</code> object is created.</li> <li>This route is called before any user inputs are provided.</li> </ul> </li> </ul>"},{"location":"technical-architecture/general-doc/#step-2-form-submission-web-app-only","title":"Step 2: Form Submission (Web App Only)","text":"<ul> <li>Route: <code>POST /user_task_execution_run</code></li> <li>Action: Sets the start date of the <code>UserTaskExecution</code> and begins generating a response from the assistant.</li> <li>Details:<ul> <li>The <code>SessionController</code> handles chat exchanges and processes form inputs to generate the assistant's response.</li> </ul> </li> </ul>"},{"location":"technical-architecture/general-doc/#step-3-message-handling-mobile-app","title":"Step 3: Message Handling (Mobile App)","text":"<ul> <li>Route: <code>PUT /user_message</code></li> <li>Action: Sends a user message and ensures the associated <code>UserTaskExecution</code> is started.</li> <li>Details:<ul> <li>The route verifies if the <code>UserTaskExecution</code> is started; if not, it starts it.</li> <li>Manages speech-to-text conversion and handles potential timeouts or crashes.</li> <li>Uses a frontend-managed message ID to re-query the route in case of crash that would let the route to answer without providing <code>message_pk</code>.</li> </ul> </li> </ul>"},{"location":"technical-architecture/general-doc/#data-storage","title":"Data Storage","text":"<ul> <li>Initial User Inputs: Stored in the <code>UserTaskExecution</code> table under <code>JsonInputValues</code>.</li> <li>Messages: Stored in the <code>md_message</code> table in a JSON field.</li> <li>Produced Text Versions: Stored in the <code>md_produced_text_version</code> table, containing titles and bodies of each version.</li> </ul>"},{"location":"technical-architecture/general-doc/#12-task-execution-workflow","title":"12. Task Execution (<code>workflow</code>)","text":""},{"location":"technical-architecture/general-doc/#1211-user-interaction","title":"121.1 User Interaction","text":"<ol> <li>Task Selection: The user clicks on \"New Task\" and sees a list of available tasks.</li> <li>Task Initiation: The user selects a workflow task and fills out the form.</li> <li>Workflow Execution:<ul> <li>The user is presented with a process tab detailing each step of the workflow.</li> <li>Steps can start and complete, with the user receiving updates via Socket.io events.</li> <li>Some steps may require user validation before proceeding to the next step.</li> <li>The user can interact with the assistant through buttons like <code>restart</code>, <code>edit</code>, and <code>review</code>.</li> </ul> </li> </ol>"},{"location":"technical-architecture/general-doc/#122-technical-description","title":"12.2 Technical Description","text":""},{"location":"technical-architecture/general-doc/#step-1-task-initialization_1","title":"Step 1: Task Initialization","text":"<ul> <li>Route: <code>PUT /user_task_execution</code></li> <li>Action: Creates an instance of <code>UserTaskExecution</code> with a <code>json_input</code> field initialized with null values.</li> <li>Details:<ul> <li>Similar to <code>instruct</code> tasks, a new <code>UserTaskExecution</code> object is created when a user starts a task.</li> </ul> </li> </ul>"},{"location":"technical-architecture/general-doc/#step-2-form-submission","title":"Step 2: Form Submission","text":"<ul> <li>Route: <code>POST /user_task_execution_run</code></li> <li>Action: Sets the start date of the <code>UserTaskExecution</code> and begins generating a response from the assistant.</li> <li>Details:<ul> <li>The <code>SessionController</code> handles chat exchanges and processes form inputs to generate the assistant's response.</li> </ul> </li> </ul>"},{"location":"technical-architecture/general-doc/#step-3-step-execution","title":"Step 3: Step Execution","text":"<ul> <li>Socket.io Events: Used to update the web app when a step starts or completes.</li> <li>User Validation: Some steps require user validation, defined by a database field associated with the workflow step.</li> <li>Buttons:<ul> <li><code>restart</code>: Available only on the first step to modify initial inputs and relaunch the workflow.</li> <li><code>edit</code>: Allows the user to modify the step result directly before validating it.</li> <li><code>review</code>: Opens a chat for the user to send instructions to the assistant to re-execute the step.</li> </ul> </li> </ul>"},{"location":"technical-architecture/general-doc/#data-storage_1","title":"Data Storage","text":"<ul> <li>Initial User Inputs: Stored in the <code>UserTaskExecution</code> table under <code>json_input_values</code>.</li> <li>Messages: Stored in the <code>md_message</code> table in a JSON field.</li> <li>Produced Text Versions: Stored in the <code>md_produced_text_version</code> table, containing titles and bodies of each version.</li> <li>File Storage: Images and audio files are stored using the <code>UserFileStorageManager</code> in the volume data, identified by session and user.</li> </ul>"},{"location":"technical-architecture/general-doc/#workflow-specifics","title":"Workflow Specifics","text":"<ul> <li>Step Validation: Each step can be validated by the user before moving to the next step.</li> <li>Final Produced Text: Generated from the last step or concatenation of the last steps, with optional chat enabled based on a database field.</li> </ul>"},{"location":"technical-architecture/general-doc/#123-workflow-execution-method-run","title":"12.3 Workflow Execution: Method <code>run()</code>","text":"<p>When a user initiates a workflow, the following sequence of events occurs:</p> <ol> <li> <p>Task Initialization:</p> <ul> <li>The user clicks on the task they want to execute.</li> <li>The <code>PUT /user_task_execution</code> route is called to instantiate a new <code>UserTaskExecution</code>.</li> </ul> </li> <li> <p>Form Submission:</p> <ul> <li>After filling out the form and clicking \"Go\", the <code>PUT /user_task_execution_run</code> route is called.</li> <li>This starts the workflow execution in a parallel thread.</li> </ul> </li> <li> <p>Workflow Execution:</p> <ul> <li>In the parallel thread, the <code>WorkflowProcessController</code> method <code>run</code> is invoked.</li> <li>The <code>run</code> method determines the step to execute and executes it.</li> </ul> </li> <li> <p>Step Execution:</p> <ul> <li>If the step does not require user validation, the <code>run</code> method is called again to calculate and execute the next step.</li> <li>If user validation is required, information is sent via <code>Socket.io</code> to the front end, indicating that user validation is needed.</li> </ul> </li> <li> <p>User Interaction:</p> <ul> <li>If the user is online, they receive a live notification.</li> <li>If the user is offline, they can see the pending validation the next time they log in.</li> </ul> </li> <li> <p>Step Validation:</p> <ul> <li>The user can either validate the step or edit the result.</li> <li>Validation calls the <code>POST /user_workflow_step_execution</code> route, marking the step as valid and re-invoking the <code>run</code> method.</li> <li>Editing calls the <code>PUT /user_workflow_step_execution_result</code> route, updating the step result and re-invoking the <code>run</code> method.</li> </ul> </li> </ol>"},{"location":"technical-architecture/general-doc/#detailed-execution-flow","title":"Detailed Execution Flow","text":"<ul> <li>The <code>run</code> method identifies the current step, executes it, and produces a result.</li> <li>If the workflow execution has no title, it generates the title and summary in a parallel process.</li> <li>The method retrieves the step to execute. If the step is <code>null</code>, the workflow is complete, and the final result is generated.</li> <li>If the step is not <code>null</code>, it executes the step, generates a result, and sends an event indicating the step completion.</li> <li>Depending on whether user validation is required, the <code>run</code> method is called again or waits for user input.</li> </ul>"},{"location":"technical-architecture/general-doc/#124-determining-the-next-step","title":"12.4 Determining the Next Step","text":""},{"location":"technical-architecture/general-doc/#step-determination-logic","title":"Step Determination Logic","text":"<ol> <li> <p>Initial Step:</p> <ul> <li>If no step has been executed, the first step is executed.</li> </ul> </li> <li> <p>Subsequent Steps:</p> <ul> <li>If one step has been executed, the next step is determined based on its rank.</li> <li>If multiple steps have been executed, the number of items in the result list of the previous step is checked.</li> <li>The next step is executed for each item in the result list until all items are processed.</li> </ul> </li> </ol>"},{"location":"technical-architecture/general-doc/#example-poem-workflow","title":"Example: Poem Workflow","text":"<ul> <li>Step 1: User inputs the poem subject and number of stanzas.</li> <li>Step 2: Generates subjects for each stanza.</li> <li>Step 3: Writes each stanza based on the generated subjects.</li> <li>The <code>run</code> method iterates through these steps, ensuring each step is executed the required number of times based on the results of the previous step.</li> </ul>"},{"location":"technical-architecture/general-doc/#125-chat-and-step-validation","title":"12.5 Chat and Step Validation","text":""},{"location":"technical-architecture/general-doc/#chat-on-step-validation","title":"Chat on Step Validation","text":"<ul> <li>If a step result is unsatisfactory, the user can initiate a chat by clicking \"Review\".</li> <li>The <code>user_workflow_step_execution</code> route is called with <code>validated=false</code>.</li> <li>A \"snapshot\" of the workflow (= parameter and result of each past steps) is taken and stored in a system message.</li> <li>The user interacts with the assistant to provide instructions for improving the step result.</li> <li>The step is re-executed with the new instructions.</li> </ul>"},{"location":"technical-architecture/general-doc/#chat-on-workflow-result","title":"Chat on Workflow Result","text":"<ul> <li>At the end of the workflow, a snapshot of the entire workflow is taken and stored in a system message.</li> <li>If the user requests modifications to the final result, the assistant uses the context from the system message to make the necessary changes.</li> </ul>"},{"location":"technical-architecture/general-doc/#13-sessioncontroller-chat-functionality","title":"13. SessionController Chat Functionality","text":""},{"location":"technical-architecture/general-doc/#chat-on-instruct-tasks-and-workflows","title":"Chat on Instruct Tasks and Workflows","text":""},{"location":"technical-architecture/general-doc/#instruct-tasks_1","title":"Instruct Tasks","text":"<ul> <li>Chat on Result: Users can send instructions about the final result of an instruct task.</li> </ul>"},{"location":"technical-architecture/general-doc/#workflows","title":"Workflows","text":"<ul> <li>Chat on Steps: Users can send instructions about individual steps if enabled.</li> <li>Chat on Result: Users can send instructions about the final result of the workflow.</li> <li>API Call Considerations: API calls cannot be repeated once the result is generated, enabling chat on workflow result could misguide users of hallucinated further API calls that would never happen.</li> </ul>"},{"location":"technical-architecture/general-doc/#entry-points","title":"Entry Points","text":"<p>The <code>SessionController</code> has two main entry points for handling chat interactions:</p> <ol> <li>process_form_input(): Called when the user clicks on \"Go\" on the WebApp in a parallel process by the route <code>POST /user_task_execution_run</code>.</li> <li>process_chat_message(): Called when a message is received from the user via the <code>PUT /user_message</code> route.</li> </ol>"},{"location":"technical-architecture/general-doc/#user_input_processor-decorator","title":"<code>@user_input_processor</code> Decorator","text":"<p>Both entry points are decorated with the <code>@user_input_processor</code> decorator. This decorator ensures that the functions will call a <code>ChatAssistant</code>, return a <code>response_message</code>, and handle adding the response to the database and streaming it.</p>"},{"location":"technical-architecture/general-doc/#differences-between-those-methods","title":"Differences between those methods","text":"<ul> <li>process_form_input(): This method is specific to instruct tasks and cannot be called outside the context of an instruct task.</li> <li>process_chat_message(): This method can be called in various contexts, including outside of a task, such as in the Home Chat context, or in workflow execution context. It includes additional checks to determine the context and handle it accordingly.</li> </ul>"},{"location":"technical-architecture/general-doc/#14-chat-assistant-functionality","title":"14. Chat Assistant Functionality","text":""},{"location":"technical-architecture/general-doc/#chatassistant-classes","title":"ChatAssistant Classes","text":"<p>The <code>ChatAssistant</code> is an abstract class responsible for generating assistant responses. It has three implementations:</p> <ol> <li>HomeChatAssistant</li> <li>InstructTaskAssistant</li> <li>WorkflowAssistant</li> </ol>"},{"location":"technical-architecture/general-doc/#common-methods","title":"Common Methods","text":"<p>The <code>ChatAssistant</code> class defines several common methods:</p> <ul> <li>_call_llm(): Makes a call to the language model.</li> <li>_handle_llm_output(): Handles the output from the language model, including extracting the language and tags.</li> </ul>"},{"location":"technical-architecture/general-doc/#abstract-methods","title":"Abstract Methods","text":"<p>Each <code>ChatAssistant</code> implementation must override the following abstract methods:</p> <ul> <li>generate_message(): Generates the message specific to the assistant.</li> <li>mpt(): A property that returns the MPT (Mojodex Prompt Template) specific to the assistant.</li> <li>_manage_response_tag(): Manages the response tags specific to the assistant.</li> <li>_token_callback(): Handles the callback for tokens, which can vary between assistants.</li> </ul>"},{"location":"technical-architecture/general-doc/#141-homechatassistant","title":"14.1 HomeChatAssistant","text":""},{"location":"technical-architecture/general-doc/#142-instruct-task-assistant","title":"14.2 Instruct Task Assistant","text":""},{"location":"technical-architecture/general-doc/#143-workflow-assistant","title":"14.3 Workflow Assistant","text":""},{"location":"technical-architecture/general-doc/#15-home-chat-functionality","title":"15. Home Chat Functionality","text":""},{"location":"technical-architecture/general-doc/#overview","title":"Overview","text":"<p>The Home Chat Assistant is a feature implemented in the mobile app but is currently not in active use. It is present in the main branch of the mobile app but has not been fully tested and lacks a defined use case.</p>"},{"location":"technical-architecture/general-doc/#session-initialization","title":"Session Initialization","text":"<p>When a user navigates to the Home Chat page, a session is initiated, allowing the user to exchange messages with the assistant without selecting or starting any specific user task.</p>"},{"location":"technical-architecture/general-doc/#task-execution","title":"Task Execution","text":"<ul> <li>The assistant can start an instruct task at any moment based on the user's natural conversation.</li> <li>For example, if a user mentions wanting to post on LinkedIn, the assistant can initiate the task to write a LinkedIn post.</li> </ul>"},{"location":"technical-architecture/general-doc/#maintaining-task-execution-consistency","title":"Maintaining Task Execution Consistency","text":"<ul> <li>The goal is to maintain consistency between tasks started by user clicks and those initiated by the assistant.</li> <li>This is managed by detecting during the assistant's response streaming (in the <code>_token_callback</code> function) whether a task has been started.</li> </ul>"},{"location":"technical-architecture/general-doc/#token-callback-_token_callback-function","title":"Token Callback  <code>_token_callback</code> Function","text":"<ul> <li>The partially generated text is analyzed to check for <code>&lt;task_pk&gt;</code> and <code>&lt;/task_pk&gt;</code> tags on the fly.</li> <li>If these tags are detected, the value between them is extracted to determine the task context.</li> <li>If a <code>task_pk</code> is present, it indicates a task context; otherwise, it does not.</li> </ul>"},{"location":"technical-architecture/general-doc/#task-decision-process","title":"Task Decision Process","text":"<ul> <li>If the assistant decides to start a task, it begins its response with <code>&lt;task_pk&gt;</code>, the task number, and <code>&lt;/task_pk&gt;</code>. i.e. <code>&lt;task_pk&gt;12&lt;/task_pk&gt;</code></li> <li>The assistant has access to the list of tasks available to the user, including their PKs.</li> <li>The function checks if the tags are detected and processes accordingly:</li> <li>If <code>task_pk</code> is <code>null</code> and no task is running, the assistant continues with a general message.</li> <li>If <code>task_pk</code> is <code>null</code> but a task was running, it indicates the task has ended, and the running task is set to <code>false</code>.</li> <li>If a <code>task_pk</code> is detected and no task is running, it signals the start of a new task, and the function returns, stopping further token processing.</li> </ul>"},{"location":"technical-architecture/general-doc/#implementation-details","title":"Implementation Details","text":"<ul> <li>The assistant's context changes when a task is running, affecting the prompt's templating.</li> <li>This way, by stopping the answer generation and adapting the prompt when a task starts, the prompt used to start a task by the assistant will be consistent with the one used when a user clicks to start a task. This ensures that both ways of initializing a task are using the same execution conditions.</li> <li>The assistant can switch tasks based on user instructions, maintaining flexibility in task management.</li> </ul>"},{"location":"technical-architecture/general-doc/#16-proper-nouns-resolution-with-mojodex","title":"16. Proper Nouns Resolution with Mojodex","text":""},{"location":"technical-architecture/general-doc/#overview_1","title":"Overview","text":"<p>Proper noun resolution is crucial for improving user experience, especially in audio chats where correcting names repeatedly can be frustrating.</p>"},{"location":"technical-architecture/general-doc/#tagging-proper-nouns","title":"Tagging Proper Nouns","text":"<ul> <li>Proper nouns are tagged in both assistant messages and user messages.</li> <li>For assistant messages, tagging proper nouns instruction is added directly in the prompt for mobile app users.</li> <li>For user messages, after transcription, the <code>POST /vocabulary</code> route is called to tag proper nouns.</li> </ul>"},{"location":"technical-architecture/general-doc/#vocabulary-management","title":"Vocabulary Management","text":"<ul> <li>When a user corrects a proper noun, the <code>PUT /vocabulary</code> route updates the spelling in all current session messages, task titles and summaries, produced_text last version.</li> <li>The corrected word is added to the user's vocabulary table if it doesn't already exist.</li> </ul>"},{"location":"technical-architecture/general-doc/#whisper-integration","title":"Whisper Integration","text":"<ul> <li>Whisper, the speech-to-text model, is used to transcribe audio messages.</li> <li>Due to Whisper API limitation, only the most recent 20 words from the user's vocabulary are passed to Whisper as prompt to improve transcription accuracy.</li> </ul>"},{"location":"technical-architecture/general-doc/#future-improvements","title":"Future Improvements","text":"<ul> <li>The system may need to handle a large number of proper nouns over time, requiring an algorithm to manage context-specific information.</li> <li>The approach may change if a different speech-to-text model is used in the future, or Whisper API changes.</li> </ul>"},{"location":"technical-architecture/general-doc/#17-placeholders-functionality","title":"17. Placeholders Functionality","text":""},{"location":"technical-architecture/general-doc/#overview_2","title":"Overview","text":"<p>Placeholders were introduced to help developers avoid excessive token consumption during development, especially when testing UI elements.</p> <p>Note: the recent raise of strong small language models that can run locally may lead to avoid using this feature, as it dramatically changes the overall behavior of the platform.</p>"},{"location":"technical-architecture/general-doc/#usage-in-instructtaskassistant","title":"Usage in InstructTaskAssistant","text":"<ul> <li>Placeholders are used to simulate responses without calling the LLM.</li> <li>In the <code>PUT /user_message</code> route, setting <code>use_message_placeholder</code> to <code>true</code> returns a \"Hello World\" response.</li> <li>Setting <code>use_draft_placeholder</code> to <code>true</code> returns a fake produced_text (draft message).</li> </ul>"},{"location":"technical-architecture/general-doc/#usage-and-limitations-in-workflowassistant","title":"Usage and Limitations in WorkflowAssistant","text":"<ul> <li>WorkflowTasks can generate various message types, making the current placeholder system less effective.</li> <li>Currently, placeholders can simulate <code>&lt;ask_for_clarification&gt;</code> and produced_text (draft message) but not other types like <code>&lt;user_instruction&gt;</code>.</li> </ul>"},{"location":"technical-architecture/general-doc/#usage-and-limitations-in-homechatassistant","title":"Usage and Limitations in HomeChatAssistant","text":"<ul> <li>For the Home Chat Assistant, setting <code>use_message_placeholder</code> to <code>true</code> returns a \"Hello World\" message.</li> <li>Other types of messages can't be simulated using placeholders.</li> </ul>"},{"location":"technical-architecture/general-doc/#future-considerations","title":"Future Considerations","text":"<ul> <li>The need for placeholders may decrease with the availability of powerful open-source LLMs for local development.</li> <li>For WorkflowTasks, creating specific test data might be more practical than implementing a complex placeholder mechanism.</li> </ul>"},{"location":"technical-architecture/general-doc/#18-document-management","title":"18. Document Management","text":""},{"location":"technical-architecture/general-doc/#overview_3","title":"Overview","text":"<p>The document management system in Mojodex was designed with future functionalities in mind, particularly for Retrieval-Augmented Generation (RAG), although RAG is not currently implemented. The system is equipped to handle documents and is integrated into the Mojodex web application.</p>"},{"location":"technical-architecture/general-doc/#web-app-integration","title":"Web App Integration","text":"<p>In the Mojodex web application, there is a \"Resources\" tab where users can add documents they wish to save. These documents can later be utilized in various Mojodex functionalities. Currently, users can only add web pages as documents. During the onboarding process, users have the option to add their company's website, which is then transformed into a user document.</p> <p>When dealing with tasks that require file inputs, the files are stored in the session for task execution and are not added to the document storage. The primary purpose of storing documents is to allow the assistant to dynamically use them to add contextual information during task execution or in a chat.</p>"},{"location":"technical-architecture/general-doc/#document-processing","title":"Document Processing","text":"<p>To transform a website into a document, the user provides a URL. The system then fetches all links related to the provided URL, up to a maximum of 100 links. Each of these URLs is scraped for its HTML content, which is then treated as a text document. The system only processes links directly related to the initial URL and does not follow links within those links.</p>"},{"location":"technical-architecture/general-doc/#chunking-strategy","title":"Chunking Strategy","text":"<p>The document service in Mojodex Core, a singleton service, handles the addition of new documents through the <code>add_new_document()</code> method. This method naively chunks the document text based on token count, punctuation, and new lines. The chunking strategy is simple and may not be optimal for all use cases. The current method does not overlap chunks, meaning each character belongs to only one chunk.</p>"},{"location":"technical-architecture/general-doc/#embedding-and-storage","title":"Embedding and Storage","text":"<p>Once the text is split into chunks, each chunk is embedded and stored in the <code>md_document_chunk</code> table in the database. Each chunk is stored with its text, its order within the document, and its vector. The order is used to concatenate and recreate the document in the correct sequence for the user.</p>"},{"location":"technical-architecture/general-doc/#document-retrieval","title":"Document Retrieval","text":"<p>Although not currently used, the document service includes a method to retrieve documents based on vector distance calculations. This method takes a query, embeds it to form a vector, and uses the pgVector <code>cosine_distance()</code> method to find the nearest neighbors to the query. These nearest neighbors can then be used for various functionalities.</p>"},{"location":"technical-architecture/general-doc/#19-mojodex-advanced-features-predefined-actions","title":"19. Mojodex Advanced Features: Predefined Actions","text":""},{"location":"technical-architecture/general-doc/#overview_4","title":"Overview","text":"<p>Predefined Actions in Mojodex allow for chaining Task Executions. This feature is currently available only on the mobile app. It enables the execution of a subsequent task using the result of the previous task, maintaining the same context.</p> <p></p>"},{"location":"technical-architecture/general-doc/#implementation-details_1","title":"Implementation Details","text":"<ul> <li>Task Association: Tasks that can be chained are defined at the task level. There is an association table called <code>md_task_predefined_action_association</code> that links two tasks.</li> <li>User Task Execution: When a user clicks on a predefined action, it triggers the creation and execution of a new User Task Execution. The user message for this new task is prefixed with a message defined in the Predefined Action, followed by the result of the previous User Task.</li> <li>Tracking Chain: Each User Task Execution that is launched from another task can be traced back using the attribute <code>predefined_action_from_user_task_execution_fk</code>, which indicates the originating task.</li> </ul>"},{"location":"technical-architecture/general-doc/#developer-instructions","title":"Developer Instructions","text":"<ol> <li>Creating a Predefined Action:</li> <li>First, create the subsequent task.</li> <li>Then, establish the association between the tasks. This can be done during the creation or editing of a task.</li> <li>Example: After a meeting summary, a follow-up email can be automatically triggered.</li> </ol>"},{"location":"technical-architecture/general-doc/#common-use-case","title":"Common Use Case","text":"<ul> <li>Meeting Minutes Predefined action: After a meeting, it is common to send a follow-up email. This feature allows for the automatic chaining of these tasks.</li> </ul>"},{"location":"technical-architecture/general-doc/#20-mojodex-advanced-features-text-edit-actions","title":"20. Mojodex Advanced Features: Text-Edit Actions","text":""},{"location":"technical-architecture/general-doc/#overview_5","title":"Overview","text":"<p>Text-Edit Actions are shortcuts for editing the output of a task without sending a chat message. This feature is also currently available only on the mobile app and helps users discover the editing capabilities of Mojodex.</p> <p></p>"},{"location":"technical-architecture/general-doc/#implementation-details_2","title":"Implementation Details","text":"<ul> <li>Text-Type Association: Text-Edit Actions are defined at the text-type level. Each task output is associated with a text-type (e.g., document, email).</li> <li>User Interaction: When a user clicks on a Text-Edit Action, it generates a user message in the chat, which is then processed by calling the <code>text_edit_action</code> route instead of the classic <code>user_message</code> route.</li> <li>Prompt Storage: The prompt for each Text-Edit Action is stored in a file, and the path to this file is stored in the database. The file itself is typically a <code>.txt</code> file and is stored in <code>mojodex_core</code>.</li> </ul>"},{"location":"technical-architecture/general-doc/#developer-instructions_1","title":"Developer Instructions","text":"<ol> <li>Defining Text-Edit Actions:</li> <li>Associate the Text-Edit Actions with a text-type.</li> <li>Ensure that the prompt files are correctly stored and referenced in the database.</li> </ol>"},{"location":"technical-architecture/general-doc/#common-use-case_1","title":"Common Use Case","text":"<ul> <li>Email Editing: Users can quickly make an email less formal or shorter by using predefined Text-Edit Actions.</li> </ul>"},{"location":"technical-architecture/general-doc/#21-mojodex-advanced-features-todo-management","title":"21. Mojodex Advanced Features: Todo Management","text":""},{"location":"technical-architecture/general-doc/#overview_6","title":"Overview","text":"<p>Todo Management in Mojodex involves the extraction and scheduling of ToDo items based on user task executions. This process runs in the background and helps users keep track of their tasks.</p>"},{"location":"technical-architecture/general-doc/#implementation-details_3","title":"Implementation Details","text":"<ul> <li>Todo Extraction:</li> <li>Every 10 minutes, a scheduler triggers the extraction of todos from user task executions whose latest <code>md_produced_text_version</code> is between 10 and 20 minutes old.</li> <li>The assistant extracts actionable items mentioned by the user and adds them to the todo list, scheduling them for future dates.</li> <li>Todo List Access:</li> <li>Users can view their todo list in the todo tab of the mobile or web app, or directly from a user task execution.</li> <li>Todo Execution:</li> <li>Todos can be marked as done or deleted by the user.</li> <li>Replanning of todos is done by the assistant every hour for todos that are overdue.</li> </ul>"},{"location":"technical-architecture/general-doc/#features_1","title":"Features","text":"<ol> <li>Background Extraction:</li> <li>The scheduler is set to run every 10 minutes to extract todos.</li> <li>The assistant is prompted to extract and reformulate todos from user task executions - only ToDo items explicitely mentioned as so by user.</li> <li>Todo Replanning:</li> <li>The scheduler runs every hour to replan overdue todos.</li> <li>The assistant replans these todos and updates the database accordingly.</li> <li>Email Notifications:</li> <li>Users with the attribute <code>todo_email_reception</code> set at true receive a daily email between 8 AM and 9 AM (weekdays only) with their todos for the day and any replanifications.</li> <li>The email service can be configured using SMTP or AWS.</li> </ol>"},{"location":"technical-architecture/general-doc/#common-use-case_2","title":"Common Use Case","text":"<ul> <li>Meeting Follow-up Actions: Extracting follow-up actions from meeting summaries and adding them to the todo list.</li> </ul>"},{"location":"technical-architecture/general-doc/#22-administration-and-configuration-of-the-platform","title":"22. Administration and Configuration of the platform","text":"<p>The goal of this section is to describe how to prepare and configure the Mojodex platform with users, tasks and how tasks are made usable by users</p>"},{"location":"technical-architecture/general-doc/#221-user-creation","title":"22.1 User Creation","text":"<p>There are two methods to create a new user:</p> <ol> <li> <p>User Self-Registration:</p> <ul> <li>The user visits the web or mobile app and clicks on <code>Sign Up</code>.</li> <li>They fill out a form with their name, email, and password.</li> <li>After signing up, they go through an onboarding process:<ol> <li>Accept Terms and Conditions.</li> <li>Choose a profile category, which determines the tasks they can access.</li> <li>Optionally, enter their company's website for additional context.</li> </ol> </li> <li>The user's account is created and associated with a free trial product of the chosen category.    <code>Note: a free trial is particular product that is limited wether in terms of days of use or number of tasks to run AND it's free, i.e. product.is_free = true</code></li> </ul> </li> <li> <p>Admin-Created User:</p> <ul> <li>An admin calls the <code>PUT /user</code> route with the <code>skip_user_validation=true</code> parameter. Terms and conditions are \"validated\" by default, onboarding is skipped.</li> <li>The user receives an email to change their default password.</li> <li>The admin must assign a role or purchase to the user to grant access to tasks.</li> </ul> </li> </ol>"},{"location":"technical-architecture/general-doc/#222-product-and-profile-management","title":"22.2 Product and Profile Management","text":"<p>Products and profiles in Mojodex are used to group tasks and manage user access:</p> <ol> <li> <p>Product:</p> <ul> <li>A product is a collection of tasks associated with a specific user profile.</li> <li>Products are grouped into categories (e.g., recruiters, engineers).</li> <li>Each product can have different task lists tailored to specific job (e.g., managers, interns).</li> </ul> </li> <li> <p>Profile: <code>Products</code> and <code>Profiles</code> are represented with the same DB object: <code>md_product</code>. <code>Profile</code> is a specialized representation of the <code>product</code> concept, better adapted to \u201cadmin all set config\u201d where user has no control over the tasks they can access. A profile is:</p> </li> <li>free</li> <li>has no limit</li> <li> <p>has no Stripe ID</p> </li> <li> <p>Subscription: <code>Products</code> and <code>Subscription</code> are represented with the same DB object: <code>md_product</code>. A <code>Subscription</code> is a particular type of product that has no limit in terms of number of tasks run and duration.</p> </li> </ol>"},{"location":"technical-architecture/general-doc/#223-purchase-and-role-management","title":"22.3 Purchase and Role Management","text":"<p>Purchases and roles link users to products and profiles:</p> <ol> <li> <p>Purchase:</p> <ul> <li>A purchase is the association between a user and a product.</li> <li>When a user makes a new purchase, their task access is updated.</li> </ul> </li> <li> <p>Role: <code>Purchases</code> and <code>Roles</code> are represented with the same DB object: <code>md_purchase</code>. Role is better adapted to \u201cadmin all set config\u201d where user has no control over the tasks they can access. A <code>role</code> is making the relationship between a <code>user</code> and a <code>profile</code> which is a special <code>product</code> (as seen in the previous section).</p> </li> </ol>"},{"location":"technical-architecture/general-doc/#224-purchase-and-subscription-management","title":"22.4 Purchase and Subscription Management","text":"<p>A user can't have 2 active purchases of a <code>Subscription</code> at the same time. When purchasing a subscription, if user already has a <code>Subscription</code> purchase, this one will be deactivated before adding the new <code>purchase</code>.</p>"},{"location":"technical-architecture/general-doc/#225-database-entities-relationship","title":"22.5 Database Entities Relationship","text":""},{"location":"technical-architecture/general-doc/#226-procedure-to-create-a-new-product","title":"22.6 Procedure to create a new Product","text":"<p>Creating a New Product: 1. Create a product category: <code>PUT /product_category</code> 2. Within the category, create products for different user types: <code>PUT /product</code> (or <code>PUT /profile</code>) 3. Associate tasks with each product: <code>PUT /product_task_association</code> 4. Link users to products via purchases. <code>PUT /manual_purchase</code> (or <code>PUT /role</code>)</p> <p>Each operation can be done using the appropriate backend routes.</p>"},{"location":"technical-architecture/general-doc/#23-overview-of-mojodex-db-tables","title":"23. Overview of Mojodex DB Tables","text":"<p>Mojodex's database is composed of several tables, each serving a specific purpose. The main categories of tables include:</p> <ul> <li>Users: Configuration of user accounts, profiles, etc.</li> <li>Documents: Configuration related to user documents and companies.</li> <li>Tasks Configuration: How tasks are configured.</li> <li>Tasks Execution: How users execute tasks.</li> </ul> <p>Access to the database documentation: - https://dbdiagram.io/d/MojodexDatabase-659d0645ac844320ae85b440 - https://dbdocs.io/kelly.roussel/Mojodex</p>"},{"location":"technical-architecture/general-doc/#231-users","title":"23.1 Users","text":""},{"location":"technical-architecture/general-doc/#user-table","title":"User Table","text":"<p>The User table is the central table in Mojodex. It contains essential elements for user identification, configuration data, authentication information, foreign keys to configuration tables, company information, time zones, and links to product categories. The product category determines the list of products that can be purchased by the user.</p>"},{"location":"technical-architecture/general-doc/#product-and-category-configuration","title":"Product and Category Configuration","text":"<p>Before adding users, products and categories must be configured. This involves defining categories (i.e recruitement) for a given deployment, then creating associated products (i.e manager).  Note: Each product category defines an implicit goal for the user, providing additional context for task execution.</p>"},{"location":"technical-architecture/general-doc/#purchase-and-payment-systems","title":"Purchase and Payment Systems","text":"<p>A Purchase links a user to a product, validating their access. Mojodex, designed as a SaaS product, integrates with Stripe payment system. It also supports custom B2B relationships, allowing for invoice validation through a custom Purchase ID.</p> <p></p>"},{"location":"technical-architecture/general-doc/#232-documents","title":"23.2 Documents","text":""},{"location":"technical-architecture/general-doc/#display-data","title":"Display Data","text":"<p>Display data stores translation information, which is practical for backend flexibility despite adding some load to the database structure.</p>"},{"location":"technical-architecture/general-doc/#user-documents","title":"User Documents","text":"<p>Users are linked to documents like websites. These documents provide context information for task execution.</p>"},{"location":"technical-architecture/general-doc/#vocabulary","title":"Vocabulary","text":"<p>User vocabulary stores proper names used by the user, enhancing the assistant's recognition capabilities. </p>"},{"location":"technical-architecture/general-doc/#events-management","title":"Events Management","text":"<p>Events log notifications sent to users, including emails and push notifications.</p>"},{"location":"technical-architecture/general-doc/#devices-and-notifications-management","title":"Devices and Notifications Management","text":"<p>The Device table stores Firebase Messaging tokens for user devices, ensuring notifications are sent to all valid devices. Invalid tokens are marked as such to maintain accuracy.</p> <p>Note: with this representation, if a user has multiple accounts on the same device, all notifications of all accounts will be sent to this device</p>"},{"location":"technical-architecture/general-doc/#233-tasks-configuration","title":"23.3 Tasks Configuration","text":""},{"location":"technical-architecture/general-doc/#task","title":"Task","text":"<p>Tasks are the core of Mojodex, divided into two types: Instruct and Workflow \u2013 but same table <code>md_task</code>. Task configuration includes defining task types, names, system definitions, display information, output formats, and more. Tasks are associated with platforms (e.g., mobile, web) to control their availability.</p>"},{"location":"technical-architecture/general-doc/#product-tasks","title":"Product Tasks","text":"<p>Product Tasks link products to tasks, determining the list of tasks available for a given product.</p>"},{"location":"technical-architecture/general-doc/#workflow-and-steps","title":"Workflow and Steps","text":"<p>Workflows consist of ordered steps defined in the <code>md_workflow_step</code> table. Each step includes information to process the workflow.</p>"},{"location":"technical-architecture/general-doc/#actions","title":"Actions","text":"<p>Tasks can have predefined actions linking them to other tasks, enabling task chaining. For example, after a meeting summary, a follow-up email task can be triggered.</p> <p></p>"},{"location":"technical-architecture/general-doc/#234-tasks-executions","title":"23.4 Tasks Executions","text":""},{"location":"technical-architecture/general-doc/#task-execution-and-sessions","title":"Task Execution and Sessions","text":"<p>Task execution involves the UserTaskExecution table, which links to user tasks, sessions, and purchases. Sessions manage all exchanges during task execution, including messages between the user and the assistant.</p>"},{"location":"technical-architecture/general-doc/#inputs-and-messages","title":"Inputs and Messages","text":"<p>Users can start tasks via forms or messages. Form inputs are stored in <code>user_task_execution.json_input.values</code>, while message-based inputs are managed through message exchanges. </p> <p>Note for message-based execution: at the start of a task AND even in the context of a chat over an already existing user_task_execution, inputs are not re-extracted but concatenated in the run task template, as conversation history.</p>"},{"location":"technical-architecture/general-doc/#task-results-and-produced-text-versions","title":"Task Results and Produced Text Versions","text":"<p>Task execution results are stored in ProducedTextVersion, with multiple versions possible due to user edits or text-edit actions. The most recent version is considered the final result.</p>"},{"location":"technical-architecture/general-doc/#todos","title":"ToDos","text":"<p>ToDos are extracted at the end of a UserTaskExecution and can have various statuses (e.g., completed, pending, deleted). They are associated with a schedule, which can be adjusted over time.</p>"},{"location":"technical-architecture/general-doc/#home-chat-interactions","title":"Home Chat Interactions","text":"<p>The Home Chat table manages chat interactions not necessarly linked to specific tasks, maintaining context for a week. This allows users to chat with an assistant about various topics, with interactions stored in sessions.</p> <p></p>"},{"location":"technical-architecture/integration/hubspot/","title":"Hubspot integration","text":"<p>Hubspot integration stands as a demonstration of how to integrate a third-party service with the platform. The integration is implemented as an action on task result to export a produced text directly to Hubspot.</p>"},{"location":"technical-architecture/integration/hubspot/#configuration","title":"Configuration","text":"<p>Using Hubspot integration requires setting an <code>HUBSPOT_ACCESS_TOKEN</code> variable in the <code>.env</code> file of Mojodex project. The access token can be obtained from the Hubspot account settings.</p> <p>For the \"export to Hubspot\" button to be display in mobile application, ensure the <code>HUBSPOT_BUTTON</code> variable is set to <code>\"true\"</code> in the <code>.env</code> file of the mobile application.</p>"},{"location":"technical-architecture/integration/hubspot/#export-task-result","title":"Export task result","text":""},{"location":"technical-architecture/integration/hubspot/#backend","title":"Backend","text":"<p>On the backend side, the integration is implemented as 2 routes. Resources can be found in <code>backend/app/routes/integrations/hubspot.py</code> file.</p> <ul> <li> <p>GET route: retrieves <code>n_results</code> from <code>search_type</code> ('companies', 'contacts' or 'deals') which name starts with <code>search_string</code>. This route is used for user to browse their Hubspot account and select the entity to which the text will be exported.</p> </li> <li> <p>POST route: exports the task result associated with <code>produced_text_version_pk</code> as an <code>engagement_type</code> (among 'notes', 'emails', 'calls' and 'meetings') to <code>associated_object_id</code> of <code>associated_object_type</code> (among 'companies', 'contacts' or 'deals').</p> </li> </ul>"},{"location":"technical-architecture/integration/hubspot/#frontend","title":"Frontend","text":"<p>On frontend side, only mobile application supports Hubspot integration for now. The integration is implemented as an export button in the task result details view. </p> <p>The button opens a modal with a form to select the entity to which the text will be exported.</p> <p> </p>"},{"location":"technical-architecture/integration/hubspot/#future-work-hubspot-as-third-party-tool","title":"Future work - Hubspot as third party tool","text":"<ul> <li>Implement a tool to browse Hubspot entities past notes</li> <li>Use this tool to create a background task <code>Pre-call Brief</code>: <code>Create a concise summary of past interactions with the individual prior to initiating a business-oriented phone call.</code></li> </ul>"},{"location":"technical-architecture/llm-features/","title":"Large Language Models in Mojodex","text":"<p>As an AI agent, Mojodex uses cognitive functions powered by LLMs.</p>"},{"location":"technical-architecture/llm-features/#providers","title":"Providers","text":"<ul> <li>OpenAI GPT-4o</li> <li>Azure Open AI Services</li> <li>Mistral mistral-medium &amp; mistral-large</li> </ul>"},{"location":"technical-architecture/llm-features/azure/","title":"Azure Open AI Services","text":"<p>Setup the configuration keys in your <code>models.conf</code> file:</p> <pre><code>GPT4_AZURE_OPENAI_DEPLOYMENT_ID=&lt;your-deployment-id&gt;\nGPT4_AZURE_OPENAI_API_BASE=&lt;your-api-base&gt;\nGPT4_AZURE_OPENAI_API_VERSION=&lt;your-api-version&gt;\nGPT4_AZURE_OPENAI_KEY=&lt;your-key&gt;\n</code></pre>"},{"location":"technical-architecture/llm-features/azure/#coverage","title":"Coverage","text":"<p>GPT4-o and GPT4-Turbo has been used to develop the entire Mojodex platform. The coverage is complete.</p>"},{"location":"technical-architecture/llm-features/mistral/","title":"Mistral AI","text":"<p>To use Mistral AI, 2 ways:</p> <ul> <li>\u261d\ufe0f &gt; \ud83d\udd0c Mistral AI Platform: create a Mistral AI account and an API key.</li> </ul> <p>Configure your .env with Mistral API key</p> <pre><code># Mistral API\nMISTRAL_API_KEY=your-api-key\n</code></pre> <ul> <li>\u270c\ufe0f &gt; \ud83d\udcd6 Azure Mistral AI: create an Azure account and an API key.</li> </ul> <p>Azure Mistral API</p> <pre><code># Azure Mistral API\nMISTRAL_AZURE_API_BASE=&lt;your-azure-api-endpoint&gt;\nMISTRAL_AZURE_API_KEY=&lt;your-azure-api-key&gt;\n</code></pre>"},{"location":"technical-architecture/llm-features/mistral/#coverage","title":"Coverage","text":"<p>For the assessment, <code>mistral</code> models have been tested on the most challenging feature: <code>\"ANSWER_USER\"</code> on the Mojodex platform.</p> <p>See blog post for a better understanding of the challenge: Advanced Prompting Strategies for Digital Assistant Development</p>"},{"location":"technical-architecture/llm-features/mistral/#mistral-large","title":"<code>mistral-large</code> \u2705","text":"<p>\ud83c\udf89 full coverage</p> <p><code>mistral-large</code> has been tested on all features and provides a full coverage of the Mojodex cognitive functions.</p>"},{"location":"technical-architecture/llm-features/mistral/#mistral-medium","title":"<code>mistral-medium</code> \ud83d\udea7","text":"<p>The results are promising, but the full coverage is not yet available.</p> <p>Some results so far</p> <p>Overall <code>mistral-medium</code> gets the idea behind the <code>data/prompts/tasks/run.txt</code> with the following limitations observed:</p> <ul> <li>\ud83d\udc4d Straightforward implementation of the API</li> <li>\ud83d\udc4d Follows the overall logic of the prompt</li> <li>\ud83d\ude15 Big variations between runs in interpretation</li> <li>\ud83d\ude15 Not reliably steerable to  defined in the prompt"},{"location":"technical-architecture/llm-features/mistral/#work-in-progress","title":"Work in progress","text":"<ul> <li> Prepare the Mistral AI provider implementation</li> <li> Run basic tests with existing prompts</li> <li> Complete the assessment on all features for <code>mistral-large</code></li> <li> Complete the assessment on all features for <code>mistral-medium</code></li> <li> Prompt Tuning: <code>mojodex_core/prompts/*</code> has been crafted for GPT-4 and GPT-4 Turbo. We need to craft prompts for Mistral AI more specifically.</li> <li> Explore guardrailing strategies to steer the model to the desired output</li> <li> For non-supported features, we can explore fine-tuning the model on our own data gathered in <code>/data/prompts_dataset</code></li> </ul>"},{"location":"technical-architecture/llm-features/mpt/","title":"Mojodex Prompt Template (MPT) File Format","text":""},{"location":"technical-architecture/llm-features/mpt/#introduction","title":"Introduction","text":"<p>This document introduces the Mojodex Prompt Template (<code>.mpt</code>) file format, a new standard designed to streamline and enhance the process of generating inputs for large language models (LLMs) within our development workflows. The <code>.mpt</code> format is a composition of jinja2 templating, HTML-like custom tagging for document formatting, and unstructured pseudo-code, enabling a flexible, powerful approach to crafting LLM prompts.</p>"},{"location":"technical-architecture/llm-features/mpt/#key-principles","title":"Key Principles","text":"<ol> <li>Prompting is coding: jinja2 templating and pseudo-code for dynamic, complex prompts.</li> <li>Divide and conquer: unified prompting library for easy multi-LLM architecture strategy.</li> <li>Token poor: reduce the token size of the prompt to optimize the LLM input.</li> </ol>"},{"location":"technical-architecture/llm-features/mpt/#motivation","title":"Motivation","text":"<p>As our reliance on LLMs increases, the complexity and variety of prompts we need to generate have grown. Traditional methods of prompt creation often involve a cumbersome, error-prone process of manually editing and formatting text, lacking standardization and efficiency. The <code>.mpt</code> format aims to address these challenges by providing:</p> <ul> <li>Standardization: A unified file format allows for consistent prompt creation across different projects and teams.</li> <li>Efficiency: The use of jinja2 templating and custom tags streamlines the process of generating dynamic, complex prompts.</li> <li>Flexibility: Support for unstructured pseudo-code and custom tags ensures that developers can express a wide range of logic and formatting requirements.</li> <li>Version Control: A dash bang style header in each <code>.mpt</code> file specifies the LLM model version, author, and additional metadata, facilitating better management and compatibility of prompt templates over time.</li> </ul>"},{"location":"technical-architecture/llm-features/mpt/#mpt-file-format-specification","title":"<code>.mpt</code> File Format Specification","text":""},{"location":"technical-architecture/llm-features/mpt/#header","title":"Header","text":"<p>The <code>.mpt</code> file begins with a dash bang style header that includes essential metadata:</p> <pre><code>#! gpt4-turbo/2023-03-15-preview\n#! gpt-4-turbo-preview\n</code></pre>"},{"location":"technical-architecture/llm-features/mpt/#body","title":"Body","text":"<p>The body of the <code>.mpt</code> file contains a mix of jinja2 templates, custom HTML-like tags, and pseudo-code:</p> <pre><code>&lt;template&gt;\n    &lt;title&gt;\n        Hello, {{ name }}! This is a sample template.   \n    &lt;/title&gt;    \n    &lt;content&gt;\n        &lt;if not all informations required display a special message, otherwise do something&gt;\n    &lt;/custom_logic&gt;\n&lt;/template&gt;\n</code></pre>"},{"location":"technical-architecture/llm-features/mpt/#advanced-templating-techniques","title":"Advanced Templating Techniques","text":"<p>To accommodate the unique requirements and capabilities of different LLM models within a single MPT file, advanced templating techniques are employed. This approach allows developers to specify model-specific prompts and logic, ensuring optimal interaction with each model's unique interpretation and response characteristics.</p>"},{"location":"technical-architecture/llm-features/mpt/#example-of-model-specific-templating","title":"Example of Model-Specific Templating","text":"<p>Consider a scenario where different models, such as <code>mistral-medium</code>, <code>gpt-4-turbo</code>, and <code>mistral-large</code>, require tailored prompts to achieve the same task. The <code>.mpt</code> file can contain directives (shebangs) and conditional templating to customize the prompt for each model:</p> <pre><code>#! mistral:instruct\n#! mistral-medium\n#! gpt4-turbo/2023-03-15-preview\n#! gpt-4-turbo-preview\n#! mistral-large\n\nYOUR CONTEXT\n{{mojo_knowledge}}\n\nGLOBAL CONTEXT\n{{user_datetime_context}}\n\nUSER NAME\n{{username}}\n\n{% if user_company_knowledge %}USER'S COMPANY KNOWLEDGE\n{{user_company_knowledge}}{% endif %}\n\nHere is the task achieved by your user.\n-------\nTASK TO ACCOMPLISH\n{{task_name}}: {{task_definition}}\n\nUSER INPUTS\n{{ user_task_inputs | tojson(indent=4) }}\n\n{% if user_messages_conversation %}CONVERSATION\n{{ user_messages_conversation }}{% endif %}\n-------\n\n{# fewshot for small models like mistral7b, i.e. mistral:instruct with ollama #}\n{% if model in [\"mistral:instruct\"] %}\nEXAMPLES OF GOOD EXECUTIONS OF THE TASK SUMMARIZATION:\n\nEXAMPLE 1:\n------\nTASK TO ACCOMPLISH\nstructure_ideas_into_doc: The user needs assistance to turn ideas into a structured written doc\n\nUSER INPUTS:\npr\\\\u00e9pare une note de musique\n\nTASK RESULT:\n&lt;title&gt;Structuration d'une Note de Musique&lt;/title&gt;\n&lt;summary&gt;Assistance fournie pour transformer des id\\u00e9es en un document structur\\u00e9. Le sujet principal \\u00e9tait la pr\\u00e9paration d'une note de musique. Le processus a impliqu\\u00e9 la transcription et l'organisation des id\\u00e9es fournies.&lt;/summary&gt;\n------\n{% endif %}\n\nGive a title to this task execution so that the user can remember what the task was about. Give important information in the title such as names, subjects...\nMake a summary of this task execution so that the user can remember what the task was about.\nSummary is addressed to the user. No need to call them.\n10 words max for the title and 3 sentences max for the summary.\nFormat:\n&lt;title&gt;TITLE&lt;/title&gt;\n&lt;summary&gt;SUMMARY&lt;/summary&gt;\n\nUse the same language as the user.\nNo talk, just title and summary.\n</code></pre> <p>This example showcases how to define complex logic and conditionally include content based on the model being used, offering unparalleled flexibility in crafting prompts for diverse LLMs.</p>"},{"location":"technical-architecture/llm-features/mpt/#mpt-workflow","title":"MPT Workflow","text":"<p>Developers create <code>.mpt</code> files following the format specification. The runtime sequence involves:</p> <pre><code>graph LR\n    A[Cleaning\\nDashbang] --&gt; B[Jinja2\\nResolution]\n    B --&gt; C[Generate\\nLLM Input]\n    C --&gt; D[\"(soon) Compression\"]</code></pre> <ol> <li>Cleaning Dashbang: The header is cleaned from the processing input to the LLM.</li> <li>Jinja2 Resolution: Templates are processed to substitute variables and expressions with actual values.</li> <li>Generate LLM Input: The cleaned, resolved template serves as the input for the appropriate LLM.</li> <li>(soon) Compression: Optimize the LLM input with compression algorithms to reduce the token size \u2013 this is optional and depends on the LLM model &amp; tokenizer.</li> </ol>"},{"location":"technical-architecture/llm-features/mpt/#example","title":"Example","text":"<p>file translation.mpt</p> <p>```</p>"},{"location":"technical-architecture/llm-features/mpt/#gpt4-turbo2023-03-15-preview","title":"! gpt4-turbo/2023-03-15-preview","text":""},{"location":"technical-architecture/llm-features/mpt/#gpt-4-turbo-preview","title":"! gpt-4-turbo-preview","text":"<pre><code>#! mistral-large\n\nTranslate this text to {{language}}:\n&lt;text_start&gt;\n{{text}}\n&lt;text_end&gt;\nIf text is already in {{language}}, return it as is.\nNo talk, just translation.\nDo not include tags in response.\n\n\n```\n</code></pre> <p>Code</p> <pre><code>&gt;&gt;&gt; mpt = MPT('translation.mpt', text='hello', language='english')\n&gt;&gt;&gt; print(mpt)\nMPT: translation.mpt\n\n&gt;&gt;&gt; print(mpt.prompt)\nTranslate this text to english:\n&lt;text_start&gt;\nhello\n&lt;text_end&gt;\nIf text is already in english, return it as is.\nNo talk, just translation.\nDo not include tags in response.\n\n\n\n&gt;&gt;&gt; print(mpt.dashbangs)\n[{'model_name': 'gpt-4-turbo', 'version': '2023-03-15-preview'}, {'model_name': 'mistral-large', 'version': 'latest'}]\n\n&gt;&gt;&gt; print(mpt.models)\n['gpt-4-turbo', 'mistral-large']\n\n&gt;&gt;&gt; print(mpt.tags) \n['&lt;text_start&gt;', '&lt;text_end&gt;']   \n</code></pre>"},{"location":"technical-architecture/llm-features/mpt/#implementation-plan","title":"Implementation Plan","text":"<p>The implementation involves developing a VSCode extension that supports the <code>.mpt</code> file format, including syntax highlighting, linting, and integration with LLM runtime processes.</p>"},{"location":"technical-architecture/llm-features/openai/","title":"Open AI","text":"<p>Setup the API key in your <code>models.conf</code> file:</p> <p><pre><code>OPENAI_API_KEY=your-api-key\n</code></pre> You can specify the provider to use as a backup in case the main provider reaches its rate limit by configuring the appropriate section in the <code>models.conf</code> file.</p>"},{"location":"technical-architecture/llm-features/openai/#coverage","title":"Coverage","text":"<p>GPT4-o has been used to develop the entire Mojodex platform. The coverage is complete.</p>"}]}